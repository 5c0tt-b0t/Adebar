#!/bin/bash
# Adebar
# (Android DEvice Backup And Restore)
# Creating scripts to backup and restore your apps, settings, and more
# Â© 2014 by Andreas Itzchak Rehberg
# Licensed using GPLv2 (see the file LICENSE which should have shipped with this)

# check parameters
if [ -z "$1" ]; then
  echo "Syntax: $0 <target_directory> [suffix]"
  exit 1
else
  OUTDIR="$1"
fi

# #################################[ Configuration ]###
# ------------------------=[ directories ]=--
#OUTDIR='.' # OUTDIR is specified via command line (mandatory parameter)
STORAGE_BASE=
USERDIR="userApps"
SYSDIR="sysApps"
PARTBACKUPDIR="images"
DOCDIR="docs"
CONFDIR="conf"
CACHEDIR=""

# -------------------=[ device specifics ]=--
SERIAL=""
DEVICE_NAME="MyDroid"

# ---------------------=[ TiBu specifics ]=--
DEVICE_IP=
TIBU_PORT="8080"
TIBU_SDINT="/storage/INTERNAL/Storage-ALL.zip"
TIBU_SDEXT="/storage/SAMSUNG_EXT_SD_CARD/Storage-ALL.zip"
TIBU_BACKUPS="/TitaniumBackup-ALL.zip"

# ---------------------------=[ Features ]=--
MK_APPDISABLE=1
MK_USERBACKUP=1
MK_SYSBACKUP=1
PULL_SETTINGS=1
MK_TIBU=0
MK_PKG_DATA=1
MK_INSTALLLOC=1
MK_DEVICEINFO=1
MK_DEVICEINFO_SENSORS=1
MK_DEVICEINFO_PMLISTFEATURES=1
MK_DEVICEINFO_STATUS=1
MK_PARTINFO=1
MK_PARTBACKUP=0
PARTITION_SRC="auto"

# -------------------=[ UserApp Specials ]=--
declare -A APP_INSTALL_SRC
declare -A APP_MARKET_URL
APP_INSTALL_SRC[org.fdroid.fdroid]="F-Droid"
APP_INSTALL_SRC[cm.aptoide.pt]="Aptoide"
APP_INSTALL_SRC[com.android.vending]="Google Play"
APP_INSTALL_SRC[com.google.android.feedback]="Google Play (Feedback)"
APP_MARKET_URL[org.fdroid.fdroid]="https://f-droid.org/repository/browse/?fdid=%s"
APP_MARKET_URL[cm.aptoide.pt]=""
APP_MARKET_URL[com.android.vending]="https://play.google.com/store/apps/details?id=%s"
APP_MARKET_URL[com.google.android.feedback]="https://play.google.com/store/apps/details?id=%s"

# Misc
PROGRESS=1
USE_ANSI=1
TIMESTAMPED_SUBDIRS=0
LINK_LATEST_SUBDIR=0
KEEP_SUBDIR_GENERATIONS=0
POSTRUN_CMD=""
APPNAME_CMD=""
ROOT_COMPAT=0

# Internal use / debugging
_OOPS_LEVEL_ADJUST=0 # 0=no_adjust; increase to "hide" oopses, decrease to force them to be revealed even on lower levels
_OOPS_REPEAT=0       # whether to show the same "oops'd line" multiple times
declare -A OOPSES    # array to store which lines where already reported

############################################[ Init ]###
BINDIR="${0%/*}"

# Checking for config file and sourcing it, if exists
if [ -d "${BINDIR}/config" ]; then
  if [ -f "${BINDIR}/config/$OUTDIR" ]; then # device-specific config
    . "${BINDIR}/config/$OUTDIR"
  elif [ -f "${BINDIR}/config/default" ]; then # default config
    . "${BINDIR}/config/default"
  fi
elif [ -f "${BINDIR}/config" ]; then # default config as of v3
  . "${BINDIR}/config"
fi

# check whether output directory shall have a suffix
if [ -n "$2" ]; then
  OUTDIR="${OUTDIR}${2}"
  TIMESTAMPED_SUBDIRS=0
elif [[ $TIMESTAMPED_SUBDIRS -gt 0 ]]; then
  OUTDIR="${OUTDIR}/$(date +"%Y%m%d%H%M")"
fi

# Check whether a device is connected at all and, if configured, the serial matches
# No device connected:
ADBOPTS=""
if [ -z "$(adb devices|egrep "^[0-9A-Za-z]+\s+device$"|awk '{print $1}')" ]; then
  echo "No device found. Make sure you have connected your device with"
  echo "USB debugging enabled, and try again."
  echo
  exit 2
fi

serials=($(adb devices|egrep "^[0-9A-Za-z]+\s+device$"|awk '{print $1}'))
# Multiple devices connected but no serial defined:
if [ -z "${SERIAL}" -a ${#serials[*]} -ne 1 ]; then
  echo "There are currently multiple devices connected, and we don't know"
  echo "which one to connect to. Please either disconnect all but the device"
  echo "you wish to retrieve data from, or specify its serial in your"
  echo "Configuration. Then try again."
  echo
  exit 3
fi

# SERIAL specified:
if [ -n "${SERIAL}" ]; then
  if [ ${#serials[*]} -eq 1 -a "${serials[0]}" != "${SERIAL}" ]; then
    echo "Your configuration specifies a serial of '${SERIAL}',"
    echo "but the connected device presents '${serials[0]}'."
    echo "Please check if you have the correct device connected, or might have"
    echo "specified the wrong parameter to the script."
    echo ""
    exit 4
  fi
  if [ ${#serials[*]} -gt 1 ]; then
    typeset -i ser=0
    for d in ${serials[*]}; do
      [ "$d" = "${SERIAL}" ] && {
        ser=1
        break
      }
    done
    if [ $ser -eq 0 ]; then
      echo "Your configuration specifies a device serial of '${SERIAL}'."
      echo "Though multiple devices seem to be connected, that is not one"
      echo "of them. Please check and try again."
      echo ""
      exit 4
    fi
  fi
  ADBOPTS="-s ${SERIAL}"
fi


# Check output directory and create it if it does not exist
if [ -n "${STORAGE_BASE}" ]; then
  OUTDIR="${STORAGE_BASE}/${OUTDIR}"
fi
DOCDIR="${OUTDIR}/${DOCDIR}"
CONFDIR="${OUTDIR}/${CONFDIR}"
PKGXML="${CONFDIR}/packages.xml"
BUILDPROP="${CONFDIR}/build.prop"
if [ ! -d "${DOCDIR}" ]; then
  mkdir -p "${DOCDIR}" || {
    echo "Output directory does not exist, and I cannot create it. Sorry."
    echo
    exit 5
  }
  mkdir -p "${CONFDIR}"
fi

# Load libraries if needed
[[ $((${MK_PARTINFO} + ${MK_PARTBACKUP})) -gt 0 ]] && . "${BINDIR}/lib/partitions.lib"
[[ $PULL_SETTINGS -eq 1 ]] && . "${BINDIR}/lib/pull_config.lib"
[[ $MK_TIBU -eq 1 ]] && . "${BINDIR}/lib/tibu.lib"
[[ $((${MK_APPDISABLE} + ${MK_USERBACKUP} + ${MK_SYSBACKUP} + ${MK_INSTALLLOC})) -gt 0 ]] && . "${BINDIR}/lib/scriptgen.lib"
[[ ${MK_DEVICEINFO} -gt 0 ]] && . "${BINDIR}/lib/deviceinfo.lib"

declare -a userApps # list of package names
declare -a sysApps
declare -a dApps


#########################################[ Helpers ]###
# Log progress (if enabled)
# Call: doProgress "what to show" [level]"
# level defaults to 1
doProgress() {
  [[ $PROGRESS -eq 0 ]] && return
  if [[ -z "$2" ]]; then
    local level=1
  else
    local level=$2
  fi
  if [[ $PROGRESS -ge $level ]]; then
    echo -e "$1"
  fi
}

# Report "oopses"
# params: in_function, in_line, msg [, log_level]
# example call: oops "pkg" "${LINENO}" "Unexpected: '$zeile'" 3
# level will be "adjusted" according to _OOPS_LEVEL_ADJUST (for debug purposes or to "hide" oopses)
# if not specified, level defaults to 2 (as "oopses" are usually informal only)
oops() {
  local level=$4
  [[ -z "$level" ]] && level=2
  [ -n "${OOPSES[$2]}" -a ${_OOPS_REPEAT} -eq 0 ] && return
  OOPSES[$2]=1
  local txt="Oops in $1 at line $2: $3"
  if [[ $level -lt 2 ]]; then
    txt=$(ansi_code "${txt}" "red")
  else
    txt=$(ansi_code "${txt}" "yellow")
  fi
  level=$(($_OOPS_LEVEL_ADJUST + $level))
  doProgress "${txt}" $level
}


# Helper: Check whether $needle is contained in $haystack[]
# Call it like: in_array $tmpstring "${P_SKIP[@]}"
in_array() {
    local hay needle=$1
    shift
    for hay; do
        [[ $hay == $needle ]] && return 0
    done
    return 1
}


#
# Wrap a string in ANSI codes
#
ansi_code() {
  if [[ USE_ANSI -eq 0 ]]; then
    echo "$1"
    return
  fi
  local txt="$1"
  shift
  while [[ -n "$1" ]]; do
    case "$1" in
      "bold")   txt="\033[1;37m${txt}" ;; # BOLD: \033[1;37m // NORMAL: \033[0;37m // # RED: \033[1;31m
      "red")    txt="\033[1;31m${txt}" ;; # more: http://tldp.org/HOWTO/Bash-Prompt-HOWTO/x329.html
      "yellow") txt="\033[1;33m${txt}" ;;
      "green")  txt="\033[1;32m${txt}" ;;
    esac
    shift
  done
  echo "${txt}\033[0m"
}


#
# Get app names by package names (if possible)
#
getAppname() {
  if [[ -z "${CACHEDIR}" ]]; then # not even cache available
    echo "$1"
    return
  fi
  if [[ -f "${CACHEDIR}/appnames/$1" ]]; then
    local name="$(cat "${CACHEDIR}/appnames/$1")"
    name="${name%"${name##*[![:space:]]}"}" # remove trailing spaces
    name="${name#"${name%%[![:space:]]*}"}" # remove leading spaces
    if [[ -z "${name}" ]]; then
      echo "$1"
    else
      echo "${name}"
    fi
    return
  fi
  # not found in cache: optionally call user script/function here
  if [[ -n "${APPNAME_CMD}" ]]; then
    name="$(${APPNAME_CMD} $1)"
    if [[ "${name}" != "$1" ]]; then
      echo "${name}" > "${CACHEDIR}/appnames/$1"
    fi
    echo "${name}"
    return
  fi
  echo "$1"
}

#
# Gather lists of installed apps
#
initAppLists() {
  [[ $(($MK_USERBACKUP + $MK_SYSBACKUP)) -eq 0 ]] && return
  doProgress "Gathering lists of installed apps"

  doProgress "- userApps" 2
  for app in $(adb ${ADBOPTS} shell pm list packages -3); do
    app=${app//[$'\t\r\n']} # remove trailing CR (^M)
    userApps+=(${app##*:})
  done
  doProgress "- systemApps" 2
  for app in $(adb ${ADBOPTS} shell pm list packages -s); do
    app=${app//[$'\t\r\n']}
    sysApps+=(${app##*:})
  done
  doProgress "- checking for uninstalled apps remembered by the system" 2
  for app in $(adb ${ADBOPTS} shell pm list packages -u); do
    app=${app//[$'\t\r\n']}
    in_array "${app##*:}" ${sysApps[@]} && continue
    in_array "${app##*:}" ${userApps[@]} && continue
    dApps+=($app)
    echo "Removed app: ${app##*:}"
  done
}

#
# Collect app details via dumpsys
#
getAppDetails() {
  local P_BLOCK="none" # none|pkglist|pkg|disabled|enabled|perms
  local P_PKGNAME=""   # name of the currently processed package
  local tmpstring=""
  local P_SKIP=(userId sharedUser pkg resourcePath nativeLibraryPath versionCode targetSdk timeStamp signatures permissionsFixed pkgFlags applicationInfo)
  declare -A PK_CODEPATH
  declare -A PK_VERSION
  declare -A PK_DATADIR
  declare -A PK_SCREENSIZE
  declare -A PK_FIRSTINSTALL
  declare -A PK_LASTUPDATE
  declare -A PK_INSTALLERS    # per source
  PK_INSTALLERS[none]="unknown source"
  declare -A PK_INSTALLER     # per app
  declare -A PK_DISABLED      # list of components separated by spaces
  declare -A PK_FLAGS         # flags=[ SYSTEM HAS_CODE ALLOW_TASK_REPARENTING ALLOW_CLEAR_USER_DATA ALLOW_BACKUP LARGE_HEAP ]
  declare -A PK_USERS         # User 0:  installed=true stopped=false notLaunched=false enabled=0
  declare -A APP_INSTALL_SRC
  APP_INSTALL_SRC[org.fdroid.fdroid]="F-Droid"
  APP_INSTALL_SRC[cm.aptoide.pt]="Aptoide"
  APP_INSTALL_SRC[com.android.vending]="Google Play"
  APP_INSTALL_SRC[com.google.android.feedback]="Google Play (Feedback)"
  local PKGDUMP=$(tempfile)
  trap "rm -f -- '$PKGDUMP'" RETURN
  local SH_DISABLED="${OUTDIR}/deadReceivers.sh"

  doProgress "Generating app detail info"
  doProgress "- collecting data via dumpsys" 2
  adb ${ADBOPTS} shell "dumpsys package" |egrep -A99999 "^Packages:" |egrep -B99999 "^Shared users:" > "${PKGDUMP}"

  # Parsing dump
  doProgress "- parsing package dump" 2
  while IFS='' read zeile; do # no idea why, but some dump lines are terminated using CRLF
    case ${P_BLOCK} in
      none)
        [[ "$zeile" != "Packages:" ]] && continue;
        P_BLOCK="pkglist"
        doProgress "  - Found package list marker" 4
        continue;
        ;;

      pkglist)
        if [[ "${zeile:0:11}" = "  Package [" ]]; then  # "  Package [com.google.android.location] (40e85638):"
          tmpstring="${zeile##*[}"                      # strip leading
          P_PKGNAME="${tmpstring%%]*}"                  # strip trailing
          P_BLOCK="pkg"
          doProgress "  - Package: $P_PKGNAME" 4
          continue
        fi
        ;;

      pkg)
        tmpstring="${zeile%%=*}"
        tmpstring="${tmpstring##*[[:space:]]}"
        in_array $tmpstring "${P_SKIP[@]}" && continue
        [[ "$zeile" = "    grantedPermissions:" ]] && continue
        [[ "${zeile:0:6}" = "      " ]] && continue
        [[ -z "${zeile%%* }" ]] && break # end of package list is an empty line, sometimes with spaces
        case "$tmpstring" in
          "codePath")
            PK_CODEPATH[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +codePath: ${PK_CODEPATH[$P_PKGNAME]}" 5
            continue
            ;;
          "versionName")
            PK_VERSION[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +version: ${PK_VERSION[$P_PKGNAME]}" 5
            continue
            ;;
          "dataDir")
            PK_DATADIR[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +data: ${PK_DATADIR[$P_PKGNAME]}" 5
            continue
            ;;
          "supportsScreens")
            PK_SCREENSIZE[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +screens: ${PK_SCREENSIZE[$P_PKGNAME]}" 5
            continue
            ;;
          "firstInstallTime")
            PK_FIRSTINSTALL[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +firstinst: ${PK_FIRSTINSTALL[$P_PKGNAME]}" 5
            continue
            ;;
          "lastUpdateTime")
            PK_LASTUPDATE[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +lastup: ${PK_LASTUPDATE[$P_PKGNAME]}" 5
            continue
            ;;
          "installerPackageName")
            in_array "${zeile##*=}" "${PK_INSTALLERS[@]}" || { # setting up "used sources" to group by
              if [ -z "${APP_INSTALL_SRC[${zeile##*=}]}" ]; then
                PK_INSTALLERS[${zeile##*=}]="${zeile##*=}"
              else
                PK_INSTALLERS[${zeile##*=}]="${APP_INSTALL_SRC[${zeile##*=}]}"
              fi
            }
            PK_INSTALLER[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +installer: ${PK_INSTALLER[$P_PKGNAME]}" 5
            continue
            ;;
          "flags")
            PK_FLAGS[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +flags: ${PK_FLAGS[$P_PKGNAME]}" 5
            continue
            ;;
          *)
            if [[ "${zeile:0:11}" = "  Package [" ]]; then  # "  Package [com.google.android.location] (40e85638):"
              tmpstring="${zeile##*[}"                      # strip leading
              P_PKGNAME="${tmpstring%%]*}"                  # strip trailing
              doProgress "  - Package: $P_PKGNAME" 4
              continue
            fi
            if [[ "${zeile}" = "    disabledComponents:" ]]; then
              P_BLOCK="disabled"
              continue
            fi
            if [[ "${zeile}" = "    enabledComponents:" ]]; then
              P_BLOCK="enabled"
              continue
            fi
            if [[ "${zeile:0:8}" = "    User" ]]; then  # Android 4.2+ MultiUser info
              # '    User 0:  installed=true stopped=false notLaunched=false enabled=0'
              if [[ -z "${PK_USERS[$P_PKGNAME]}" ]]; then
                PK_USERS[$P_PKGNAME]="    + ${zeile:4}"
              else
                PK_USERS[$P_PKGNAME]+="\n    + ${zeile:4}"
              fi
              continue
            fi

            oops "pkg" "${LINENO}" "Unexpected: '$zeile'" 2
            ;;
        esac
        ;;

      "disabled") # disabled components of current pkg
        if [[ "${zeile:0:6}" = "      " ]]; then
          if [[ -z "${PK_DISABLED[$P_PKGNAME]}" ]]; then
            PK_DISABLED[$P_PKGNAME]="${zeile:6}"
          else
            PK_DISABLED[$P_PKGNAME]="${PK_DISABLED[$P_PKGNAME]} ${zeile:6}"
          fi
          continue
        fi
        if [[ "${zeile}" = "    grantedPermissions:" ]]; then
          P_BLOCK="perms"
          continue
        fi
        if [[ "${zeile}" = "    enabledComponents:" ]]; then
          P_BLOCK="enabled"
          continue
        fi
        if [[ "${zeile:0:11}" = "  Package [" ]]; then  # "  Package [com.google.android.location] (40e85638):"
          tmpstring="${zeile##*[}"                      # strip leading
          P_PKGNAME="${tmpstring%%]*}"                  # strip trailing
          P_BLOCK="pkg"
          doProgress "  - Package: $P_PKGNAME" 4
          continue
        fi

        oops "disabled" "${LINENO}" "$zeile" 2
        ;;

      "enabled") # enabled components of current pkg
        if [[ "${zeile:0:6}" = "      " ]]; then
          continue # we don't include enabled components
        fi
        if [[ "${zeile}" = "    grantedPermissions:" ]]; then
          P_BLOCK="perms"
          continue
        fi
        if [[ "${zeile:0:11}" = "  Package [" ]]; then  # "  Package [com.google.android.location] (40e85638):"
          tmpstring="${zeile##*[}"                      # strip leading
          P_PKGNAME="${tmpstring%%]*}"                  # strip trailing
          P_BLOCK="pkg"
          doProgress "  - Package: $P_PKGNAME" 4
          continue
        fi

        oops "enabled" "${LINENO}" "$zeile" 2
        ;;

      "perms")
        if [[ "${zeile:0:6}" = "      " ]]; then
          continue # we don't include permissions (yet)
        fi
        if [[ "${zeile:0:11}" = "  Package [" ]]; then  # "  Package [com.google.android.location] (40e85638):"
          tmpstring="${zeile##*[}"                      # strip leading
          P_PKGNAME="${tmpstring%%]*}"                  # strip trailing
          P_BLOCK="pkg"
          doProgress "  - Package: $P_PKGNAME" 4
          continue
        fi

        oops "perms" "${LINENO}" "$zeile" 2
        ;;
      *)
        ;;
    esac

  done < "${PKGDUMP}"

  # Create userApps.md
  doProgress "- generating userApps.md" 2
  local mdfile="${DOCDIR}/userApps.md"

  echo "# Installed User-Apps on ${DEVICE_NAME}" > "${mdfile}"
  echo "(As of $(date '+%Y-%m-%d %H:%M'))" >> "${mdfile}"
  echo -e "#!/bin/bash\n# Disable Components (${DEVICE_NAME})" > "${SH_DISABLED}"
  declare -A PK_INFO
  for src in ${!PK_INSTALLERS[@]}; do
    PK_INFO[$src]=""
  done
  local CUR_INSTALLER
  local APPNAME
  for app in ${userApps[@]}; do
    APPNAME=$(getAppname "$app")
    if [[ -z "${PK_INSTALLER[$app]}" ]]; then # no installer
      if [[ "${APPNAME}" = "${app}" ]]; then
        tmpstring="+ $app\n"
      else
        tmpstring="+ ${APPNAME} (${app})\n"
      fi
    elif [[ -n "${APP_MARKET_URL[${PK_INSTALLER[$app]}]}" ]]; then
      tmpstring="+ [${APPNAME}](${APP_MARKET_URL[${PK_INSTALLER[$app]}]/\%s/$app})\n"
    else # no web source
      if [[ "${APPNAME}" = "${app}" ]]; then
        tmpstring="+ $app\n"
      else
        tmpstring="+ ${APPNAME} (${app})\n"
      fi
    fi
    [[ -n "${PK_FIRSTINSTALL[$app]}" ]] && tmpstring+="    + first installed: ${PK_FIRSTINSTALL[$app]}\n"
    [[ -n "${PK_LASTUPDATE[$app]}" ]]   && tmpstring+="    + last updated: ${PK_LASTUPDATE[$app]}\n"
    [[ -n "${PK_VERSION[$app]}" ]]      && tmpstring+="    + installed version: ${PK_VERSION[$app]}\n"
    [[ -n "${PK_CODEPATH[$app]}" ]]     && tmpstring+="    + CodePath: \`${PK_CODEPATH[$app]}\`\n"
    [[ -n "${PK_DATADIR[$app]}" ]]      && tmpstring+="    + App data: \`${PK_DATADIR[$app]}\`\n"
    [[ -n "${PK_SCREENSIZE[$app]}" ]]   && tmpstring+="    + supported screen sizes: ${PK_SCREENSIZE[$app]}\n"
    [[ -n "${PK_FLAGS[$app]}" ]]        && tmpstring+="    + flags: ${PK_FLAGS[$app]}\n"
    [[ -n "${PK_USERS[$app]}" ]]        && tmpstring+="${PK_USERS[$app]}\n"
    [[ -n "${PK_DISABLED[$app]}" ]]     && {
      tmpstring+="    + disabled components:\n"
      echo "" >> "${SH_DISABLED}"
      for comp in ${PK_DISABLED[$app]}; do
        tmpstring+="        - $comp\n"
        echo "adb shell \"pm disable ${app}/${comp}\"" >> "${SH_DISABLED}"
      done
    }
    if [[ -z "${PK_INSTALLER[$app]}" ]]; then
      PK_INFO[none]+="$tmpstring\n"
    else
      CUR_INSTALLER="${PK_INSTALLER[$app]}"
      PK_INFO[$CUR_INSTALLER]+="$tmpstring\n"
    fi
  done
  for src in ${!PK_INSTALLERS[@]}; do
    echo -e "## Installed from ${PK_INSTALLERS[$src]} (installer: $src)\n" >> "${mdfile}"
    echo -e "${PK_INFO[$src]}\n" >> "${mdfile}"
  done

  doProgress "- checking for disabled system components" 2
  echo -e "\n\n# Disable System Components" >> "${SH_DISABLED}"
  for app in ${sysApps[@]}; do
    [[ -n "${PK_DISABLED[$app]}" ]]     && {
      echo "" >> "${SH_DISABLED}"
      for comp in ${PK_DISABLED[$app]}; do
        echo "adb shell \"pm disable ${app}/${comp}\"" >> "${SH_DISABLED}"
      done
    }
  done

  doProgress "- removing temporary dumpfile" 2
  rm -f "${PKGDUMP}"
}


#
# Post processing
#
postProcess() {
  doProgress "PostProcessing and Cleanup"
  if [[ $TIMESTAMPED_SUBDIRS -gt 0 ]]; then
    if [[ $LINK_LATEST_SUBDIR -gt 0 ]]; then
      doProgress "- symlink latest generation" 2
      local LINK_NAME="$(dirname "${OUTDIR}")/latest"
      if [ -L "${LINK_NAME}" -o ! -e "${LINK_NAME}" ]; then
        rm -f "${LINK_NAME}" > /dev/null 2>&1
        ln -sf "$(basename "${OUTDIR}")" "${LINK_NAME}"
      else
        doProgress "$(ansi_code "! Cannot symlink latest generation subdir: some file/directory already uses its name" "red")"
      fi

      if [[ ${KEEP_SUBDIR_GENERATIONS} -gt 0 ]]; then
        doProgress "- remove outaged generations" 2
        declare -a GENS
        cd "$(dirname ${OUTDIR})"
        for d in $(ls -dpX [0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]); do
          [[ ${#d} -ne 13 ]] && continue
          GENS+=($d)
        done
        declare -i counter=0
        if [[ ${#GENS[@]} -gt ${KEEP_SUBDIR_GENERATIONS} ]]; then
          local HAVE_BACKUPS
          local files
          while [[ ${#GENS[@]} -gt ${KEEP_SUBDIR_GENERATIONS} ]]; do
            # We do not want to delete real backups, so make sure there are none
            HAVE_BACKUPS=0
            files=(${GENS[${counter}]:0:12}/${USERDIR}/*) # UserApps
            [[ -e "${files[0]}" ]] && HAVE_BACKUPS=1
            files=(${GENS[${counter}]:0:12}/${SYSDIR}/*)  # SysApps
            [[ -e "${files[0]}" ]] && HAVE_BACKUPS=1
            files=(${GENS[${counter}]:0:12}/*.ab)         # Any ADB backups
            [[ -e "${files[0]}" ]] && HAVE_BACKUPS=1
            files=(${GENS[${counter}]:0:12}/*.gz)         # Any .gz archives, e.g. converted by ab2tar
            [[ -e "${files[0]}" ]] && HAVE_BACKUPS=1
            if [[ $HAVE_BACKUPS -eq 0 ]]; then
              doProgress "  + removing '${GENS[${counter}]:0:12}'" 3
              rm -rf "${GENS[${counter}]:0:12}"
            else
              warning="  + '${GENS[${counter}]:0:12}' seems to contain backups. Renaming it to '${GENS[${counter}]:0:12}.Backup'"
              echo -e "$(ansi_code "$warning" "red")"
              mv "${GENS[${counter}]:0:12}" "${GENS[${counter}]:0:12}.Backup"
            fi
            unset GENS[${counter}]
            counter+=1
          done
        fi
        cd - >/dev/null
      fi
    fi
  fi

  if [[ -n "${POSTRUN_CMD}" ]]; then
    doProgress "- executing post-run command" 2
    $(${POSTRUN_CMD})
  fi
}


############################################[ Main ]###
echo
doProgress "$(ansi_code "Adebar running:" "bold")"
initAppLists
[[ ${MK_APPDISABLE} -gt 0 ]] && getDisabled
[[ ${MK_USERBACKUP} -gt 0 ]] && getUserAppBackup
[[ ${MK_SYSBACKUP} -gt 0 ]] && getSystemAppBackup
[[ ${MK_INSTALLLOC} -gt 0 ]] && getInstallLoc
[[ $((${MK_PARTINFO} + ${MK_PARTBACKUP})) -gt 0 ]] && getPartInfo
[[ ${MK_PARTBACKUP} -gt 0 ]] && writePartDumpScript
[[ ${MK_DEVICEINFO} -gt 0 ]] && getDeviceInfo
[[ $PULL_SETTINGS -eq 1 ]] && getSettings
[[ $MK_TIBU -eq 1 ]] && getTibu
[[ $MK_PKG_DATA -ne 0 ]] && getAppDetails
postProcess
doProgress "$(ansi_code "Adebar done." "bold")"
echo

exit 0


######################################[ References ]###
# pm list packages [options] <FILTER>
# options:
#    -f: See their associated file.
#    -d: Filter to only show disabled packages.
#    -e: Filter to only show enabled packages.
#    -s: Filter to only show system packages.
#    -3: Filter to only show third party packages.
#    -i: See the installer for the packages.
#    -u: Also include uninstalled packages.
#    --user <USER_ID>: The user space to query.
#
# disable a component (e.g. BroadcastReceiver): pm disable com.example.com.testapp/.TestActivity
#
# adb pull /data/system/packages.list packages.list
# apps with UID/GID and app path
