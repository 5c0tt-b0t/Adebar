#!/bin/bash
# Adebar
# (Android DEvice Backup And Restore)
# Creating scripts to backup and restore your apps, settings, and more
# Â© 2014 by Andreas Itzchak Rehberg
# Licensed using GPLv2 (see the file LICENSE which should have shipped with this)

# check parameters
if [ -z "$1" ]; then
  echo "Syntax: $0 <target_directory> [suffix]"
  exit 1
else
  OUTDIR="$1"
fi

# #################################[ Configuration ]###
# ------------------------=[ directories ]=--
#OUTDIR='.' # OUTDIR is specified via command line (mandatory parameter)
STORAGE_BASE=
USERDIR="userApps"
SYSDIR="sysApps"
PARTBACKUPDIR="images"
DOCDIR="docs"
CONFDIR="conf"
CACHEDIR=""

# -------------------=[ device specifics ]=--
SERIAL=""
DEVICE_NAME="MyDroid"

# ---------------------=[ TiBu specifics ]=--
DEVICE_IP=
TIBU_PORT="8080"
TIBU_SDINT="/storage/INTERNAL/Storage-ALL.zip"
TIBU_SDEXT="/storage/SAMSUNG_EXT_SD_CARD/Storage-ALL.zip"
TIBU_BACKUPS="/TitaniumBackup-ALL.zip"

# ---------------------------=[ Features ]=--
MK_APPDISABLE=1
MK_USERBACKUP=1
MK_SYSBACKUP=1
PULL_SETTINGS=1
MK_TIBU=0
MK_PKG_DATA=1
MK_INSTALLLOC=1
MK_DEVICEINFO=1
MK_DEVICEINFO_SENSORS=1
MK_DEVICEINFO_PMLISTFEATURES=1
MK_DEVICEINFO_STATUS=1
MK_PARTINFO=1
MK_PARTBACKUP=0
PARTITION_SRC="auto"

# -------------------=[ UserApp Specials ]=--
declare -A APP_INSTALL_SRC
declare -A APP_MARKET_URL
APP_INSTALL_SRC[org.fdroid.fdroid]="F-Droid"
APP_INSTALL_SRC[cm.aptoide.pt]="Aptoide"
APP_INSTALL_SRC[com.android.vending]="Google Play"
APP_INSTALL_SRC[com.google.android.feedback]="Google Play (Feedback)"
APP_MARKET_URL[org.fdroid.fdroid]="https://f-droid.org/repository/browse/?fdid=%s"
APP_MARKET_URL[cm.aptoide.pt]=""
APP_MARKET_URL[com.android.vending]="https://play.google.com/store/apps/details?id=%s"
APP_MARKET_URL[com.google.android.feedback]="https://play.google.com/store/apps/details?id=%s"

# Misc
PROGRESS=1
USE_ANSI=1
TIMESTAMPED_SUBDIRS=0
LINK_LATEST_SUBDIR=0
KEEP_SUBDIR_GENERATIONS=0
POSTRUN_CMD=""
APPNAME_CMD=""
ROOT_COMPAT=0

# Internal use / debugging
_OOPS_LEVEL_ADJUST=0 # 0=no_adjust; increase to "hide" oopses, decrease to force them to be revealed even on lower levels
_OOPS_REPEAT=0       # whether to show the same "oops'd line" multiple times
declare -A OOPSES    # array to store which lines where already reported

############################################[ Init ]###
BINDIR="${0%/*}"

# Checking for config file and sourcing it, if exists
if [ -d "${BINDIR}/config" ]; then
  if [ -f "${BINDIR}/config/$OUTDIR" ]; then # device-specific config
    . "${BINDIR}/config/$OUTDIR"
  elif [ -f "${BINDIR}/config/default" ]; then # default config
    . "${BINDIR}/config/default"
  fi
elif [ -f "${BINDIR}/config" ]; then # default config as of v3
  . "${BINDIR}/config"
fi

# check whether output directory shall have a suffix
if [ -n "$2" ]; then
  OUTDIR="${OUTDIR}${2}"
  TIMESTAMPED_SUBDIRS=0
elif [[ $TIMESTAMPED_SUBDIRS -gt 0 ]]; then
  OUTDIR="${OUTDIR}/$(date +"%Y%m%d%H%M")"
fi

# Check whether a device is connected at all and, if configured, the serial matches
# No device connected:
ADBOPTS=""
if [ -z "$(adb devices|egrep "^[0-9A-Za-z]+\s+device$"|awk '{print $1}')" ]; then
  echo "No device found. Make sure you have connected your device with"
  echo "USB debugging enabled, and try again."
  echo
  exit 2
fi

serials=($(adb devices|egrep "^[0-9A-Za-z]+\s+device$"|awk '{print $1}'))
# Multiple devices connected but no serial defined:
if [ -z "${SERIAL}" -a ${#serials[*]} -ne 1 ]; then
  echo "There are currently multiple devices connected, and we don't know"
  echo "which one to connect to. Please either disconnect all but the device"
  echo "you wish to retrieve data from, or specify its serial in your"
  echo "Configuration. Then try again."
  echo
  exit 3
fi

# SERIAL specified:
if [ -n "${SERIAL}" ]; then
  if [ ${#serials[*]} -eq 1 -a "${serials[0]}" != "${SERIAL}" ]; then
    echo "Your configuration specifies a serial of '${SERIAL}',"
    echo "but the connected device presents '${serials[0]}'."
    echo "Please check if you have the correct device connected, or might have"
    echo "specified the wrong parameter to the script."
    echo ""
    exit 4
  fi
  if [ ${#serials[*]} -gt 1 ]; then
    typeset -i ser=0
    for d in ${serials[*]}; do
      [ "$d" = "${SERIAL}" ] && {
        ser=1
        break
      }
    done
    if [ $ser -eq 0 ]; then
      echo "Your configuration specifies a device serial of '${SERIAL}'."
      echo "Though multiple devices seem to be connected, that is not one"
      echo "of them. Please check and try again."
      echo ""
      exit 4
    fi
  fi
  ADBOPTS="-s ${SERIAL}"
fi


# Check output directory and create it if it does not exist
if [ -n "${STORAGE_BASE}" ]; then
  OUTDIR="${STORAGE_BASE}/${OUTDIR}"
fi
DOCDIR="${OUTDIR}/${DOCDIR}"
CONFDIR="${OUTDIR}/${CONFDIR}"
PKGXML="${CONFDIR}/packages.xml"
BUILDPROP="${CONFDIR}/build.prop"
if [ ! -d "${DOCDIR}" ]; then
  mkdir -p "${DOCDIR}" || {
    echo "Output directory does not exist, and I cannot create it. Sorry."
    echo
    exit 5
  }
  mkdir -p "${CONFDIR}"
fi

# Load libraries if needed
[[ $((${MK_PARTINFO} + ${MK_PARTBACKUP})) -gt 0 ]] && . "${BINDIR}/lib/partitions.lib"
[[ $PULL_SETTINGS -eq 1 ]] && . "${BINDIR}/lib/pull_config.lib"
[[ $MK_TIBU -eq 1 ]] && . "${BINDIR}/lib/tibu.lib"

declare -a userApps # list of package names
declare -a sysApps
declare -a dApps


#########################################[ Helpers ]###
# Log progress (if enabled)
# Call: doProgress "what to show" [level]"
# level defaults to 1
doProgress() {
  [[ $PROGRESS -eq 0 ]] && return
  if [[ -z "$2" ]]; then
    local level=1
  else
    local level=$2
  fi
  if [[ $PROGRESS -ge $level ]]; then
    echo -e "$1"
  fi
}

# Report "oopses"
# params: in_function, in_line, msg [, log_level]
# example call: oops "pkg" "${LINENO}" "Unexpected: '$zeile'" 3
# level will be "adjusted" according to _OOPS_LEVEL_ADJUST (for debug purposes or to "hide" oopses)
# if not specified, level defaults to 2 (as "oopses" are usually informal only)
oops() {
  local level=$4
  [[ -z "$level" ]] && level=2
  [ -n "${OOPSES[$2]}" -a ${_OOPS_REPEAT} -eq 0 ] && return
  OOPSES[$2]=1
  local txt="Oops in $1 at line $2: $3"
  if [[ $level -lt 2 ]]; then
    txt=$(ansi_code "${txt}" "red")
  else
    txt=$(ansi_code "${txt}" "yellow")
  fi
  level=$(($_OOPS_LEVEL_ADJUST + $level))
  doProgress "${txt}" $level
}


# Helper: Check whether $needle is contained in $haystack[]
# Call it like: in_array $tmpstring "${P_SKIP[@]}"
in_array() {
    local hay needle=$1
    shift
    for hay; do
        [[ $hay == $needle ]] && return 0
    done
    return 1
}


#
# Wrap a string in ANSI codes
#
ansi_code() {
  if [[ USE_ANSI -eq 0 ]]; then
    echo "$1"
    return
  fi
  local txt="$1"
  shift
  while [[ -n "$1" ]]; do
    case "$1" in
      "bold")   txt="\033[1;37m${txt}" ;; # BOLD: \033[1;37m // NORMAL: \033[0;37m // # RED: \033[1;31m
      "red")    txt="\033[1;31m${txt}" ;; # more: http://tldp.org/HOWTO/Bash-Prompt-HOWTO/x329.html
      "yellow") txt="\033[1;33m${txt}" ;;
      "green")  txt="\033[1;32m${txt}" ;;
    esac
    shift
  done
  echo "${txt}\033[0m"
}


#
# Get app names by package names (if possible)
#
getAppname() {
  if [[ -z "${CACHEDIR}" ]]; then # not even cache available
    echo "$1"
    return
  fi
  if [[ -f "${CACHEDIR}/appnames/$1" ]]; then
    local name="$(cat "${CACHEDIR}/appnames/$1")"
    name="${name%"${name##*[![:space:]]}"}" # remove trailing spaces
    name="${name#"${name%%[![:space:]]*}"}" # remove leading spaces
    if [[ -z "${name}" ]]; then
      echo "$1"
    else
      echo "${name}"
    fi
    return
  fi
  # not found in cache: optionally call user script/function here
  if [[ -n "${APPNAME_CMD}" ]]; then
    name="$(${APPNAME_CMD} $1)"
    if [[ "${name}" != "$1" ]]; then
      echo "${name}" > "${CACHEDIR}/appnames/$1"
    fi
    echo "${name}"
    return
  fi
  echo "$1"
}

#
# Gather lists of installed apps
#
initAppLists() {
  [[ $(($MK_USERBACKUP + $MK_SYSBACKUP)) -eq 0 ]] && return
  doProgress "Gathering lists of installed apps"

  doProgress "- userApps" 2
  for app in $(adb ${ADBOPTS} shell pm list packages -3); do
    app=${app//[$'\t\r\n']} # remove trailing CR (^M)
    userApps+=(${app##*:})
  done
  doProgress "- systemApps" 2
  for app in $(adb ${ADBOPTS} shell pm list packages -s); do
    app=${app//[$'\t\r\n']}
    sysApps+=(${app##*:})
  done
  doProgress "- checking for uninstalled apps remembered by the system" 2
  for app in $(adb ${ADBOPTS} shell pm list packages -u); do
    app=${app//[$'\t\r\n']}
    in_array "${app##*:}" ${sysApps[@]} && continue
    in_array "${app##*:}" ${userApps[@]} && continue
    dApps+=($app)
    echo "Removed app: ${app##*:}"
  done
}


#
# Create script for disabled apps
#
getDisabled() {
  [ $MK_APPDISABLE -ne 1 ] && return

  doProgress "Obtaining list of disabled apps"

  local scriptname="${OUTDIR}/disable"
  echo "#!/bin/bash" > "${scriptname}"
  echo "# Disabled apps for ${DEVICE_NAME} as of $(date '+%Y-%m-%d %H:%M')" >> "${scriptname}"
  echo >> "${scriptname}"

  for app in $(adb ${ADBOPTS} shell "pm list packages -d"); do
    app=${app//[$'\t\r\n']}
    echo "adb ${ADBOPTS} shell \"pm disable ${app##*:}\"" >> "${scriptname}"
  done

  chmod u+x "${scriptname}"
}


#
# Create script to backup all user-apps
#
getUserAppBackup() {
  [ $MK_USERBACKUP -ne 1 ] && return

  doProgress "Creating backup/restore scripts for UserApps"

  local backupscript="$OUTDIR/userbackup"
  local restorescript="$OUTDIR/userrestore"
  echo "#!/bin/bash" > "$backupscript"
  echo "# Backup script for ${DEVICE_NAME} as of $(date '+%Y-%m-%d %H:%M')" >> "$backupscript"
  echo "# Backs up all user apps including their .apk files and data" >> "$backupscript"
  echo "# Feel free to comment out/remove apps you don't want/need to be backed up." >> "$backupscript"
  echo  >> "$backupscript"
  echo "[ ! -d \"${USERDIR}\" ] && mkdir \"${USERDIR}\"" >> "$backupscript"
  echo >> "$backupscript"

  echo "#!/bin/bash" > "$restorescript"
  echo "# Restore script from ${DEVICE_NAME} as of $(date '+%Y-%m-%d %H:%M')" >> "$restorescript"
  echo "# Restores all app backups. Comment out (or delete) those you do not wish to restore." >> "$restorescript"
  echo  >> "$restorescript"

  for app in "${userApps[@]}"; do
    echo -e "adb ${ADBOPTS} backup -f \"${USERDIR}/${app}.ab\" -apk $app" >> "$backupscript"
    echo "sleep 1" >> "$backupscript" # prevent ADB daemon from being "blocked" (e.g. on LG P880)
    echo -e "adb ${ADBOPTS} restore \"${USERDIR}/${app}.ab\"" >> "$restorescript"
  done

  chmod u+x "$backupscript" "$restorescript"
}


#
# Create script to backup all system-app data
#
getSystemAppBackup() {
  [ $MK_SYSBACKUP -ne 1 ] && return

  doProgress "Creating backup/restore scripts for SytemApps"

  local backupscript="$OUTDIR/sysbackup"
  local restorescript="$OUTDIR/sysrestore"
  echo "#!/bin/bash" > "$backupscript"
  echo "# Backup script for ${DEVICE_NAME} as of $(date '+%Y-%m-%d %H:%M')" >> "$backupscript"
  echo "# Backs up the data (not the .apk files) of all your system apps" >> "$backupscript"
  echo "# Feel free to comment out/remove apps you don't want/need to be backed up." >> "$backupscript"
  echo  >> "$backupscript"
  echo "[ ! -d \"${SYSDIR}\" ] && mkdir \"${SYSDIR}\"" >> "$backupscript"
  echo >> "$backupscript"

  echo "#!/bin/bash" > "$restorescript"
  echo "# Restore script from ${DEVICE_NAME} as of $(date '+%Y-%m-%d %H:%M')" >> "$restorescript"
  echo -e "# Restores all system app data backups.\n# DRAGONS HERE: this might fail if you restore to a different\n# device/Android version/ROM, so be careful!\n# Comment out/delete what you do not wish to restore." >> "$restorescript"
  echo  >> "$restorescript"

  for app in "${sysApps[@]}"; do
    prep=""
    if [ "$app" = "com.android.sharedstoragebackup" ]; then # shared storage
      prep="  "
      echo >> "$backupscript"
      echo  >> "$restorescript"
      echo -e "echo \"The following command will download 'shared storage' (i.e. contents of the SD card(s)).\"\necho \"This might take quite a while, depending on what you've stored there.\"" >> "$backupscript"
      echo -e "echo \"The following command will restore 'shared storage' (i.e. contents of the SD card(s)).\"\necho \"This might take quite a while, depending on how big your backup from it was.\"" >> "$restorescript"
      echo -e "read -n 1 -p \"Do you wish to run this command now? (Y/n) \" res\necho\nres=\$(echo \$res|tr [:upper:] [:lower:])\nif [ \"\$res\" = \"y\" ]; then" >> "$backupscript"
      echo -e "read -n 1 -p \"Do you wish to run this command now? (Y/n) \" res\necho\nres=\$(echo \$res|tr [:upper:] [:lower:])\nif [ \"\$res\" = \"y\" ]; then" >> "$restorescript"
    else
      prep=""
    fi
    echo -e "${prep}adb ${ADBOPTS} backup -f \"${SYSDIR}/${app}.ab\" -noapk $app" >> "$backupscript"
    echo "${prep}sleep 1" >> "$backupscript" # prevent ADB daemon from being "blocked" (e.g. on LG P880)
    echo -e "${prep}adb ${ADBOPTS} restore \"${SYSDIR}/${app}.ab\"" >> "$restorescript"
    if [ "$app" = "com.android.sharedstoragebackup" ]; then
      echo -e "else\n echo \"Skipping shared storage\"\nfi" >> "$backupscript"
      echo -e "else\n echo \"Skipping shared storage\"\nfi" >> "$restorescript"
      echo >> "$backupscript"
      echo  >> "$restorescript"
    fi
  done

  chmod u+x "$backupscript" "$restorescript"
}


#
# Get the default install-location
#
getInstallLoc() {
  [ $MK_INSTALLLOC -ne 1 ] && return
  doProgress "Checking default install-location"
  foo="$(adb ${ADBOPTS} shell pm get-install-location)"
  echo "#!/bin/bash" > "$OUTDIR/defaultInstallLoc"
  echo "# Set default install location for apps (taken from ${DEVICE_NAME} at $(date '+%Y-%m-%d %H:%M'))" >> "$OUTDIR/defaultInstallLoc"
  echo "pm set-install-location ${foo//[^0-9]/}" >> "$OUTDIR/defaultInstallLoc"
  chmod u+x "$OUTDIR/defaultInstallLoc"
}

#
# Get device info
#
getDeviceInfo() {
  [ $MK_DEVICEINFO -ne 1 ] && return
  doProgress "Collecting device information"
  local item=""
  local devicedoc="${DOCDIR}/deviceInfo.md"
  local msg=""
  local left
  local right
  local tmp=$(tempfile)
  trap "rm -f -- '$tmp'" RETURN

  echo "# ${DEVICE_NAME} Device Information" > "$devicedoc"
  echo "(Generated at: $(date '+%Y-%m-%d %H:%M'))" >> "$devicedoc"
  adb ${ADBOPTS} shell getprop > $tmp

  doProgress "- Evaluating device properties" 2
  declare -A DEVPROP
  declare -A HAVPROPS # groups, e.g. "wifi" for "wifi.*"

  # Parse getprop into DEVPROP & HAVPROPS
  local prop
  while read zeile; do
    [[ -z "${zeile}" ]] && continue
    zeile="${zeile//[\[\]:]/ }"
    prop=($zeile)
    [[ -z "${prop[1]}" ]] && continue
    HAVPROPS[${prop[0]%%\.*}]="y"
    DEVPROP[${prop[0]}]="${prop[1]}"
  done < "${tmp}"

  # Do something with the collected information (and collect more while on it)
  echo "## Device and ROM properties" >> "$devicedoc"
  doProgress "   + checking for product details" 3
  echo "### Product Info" >> "$devicedoc"
  echo "* Manufacturer: ${DEVPROP[ro.product.manufacturer]}" >> "$devicedoc"    # ro.product.manufacturer=Motorola
  echo "* Model: ${DEVPROP[ro.product.model]} (${DEVPROP[ro.product.device]})" >> "$devicedoc"  # ro.product.model=A953 (ro.product.device=milestone2)
  local serial="${DEVPROP[ro.serialno]}"                                        # 015ECFC703028007
  [[ -z "$serial" ]] && {
    if [[ -n "${DEVPROP[ro.boot.serialno]}" ]]; then
      serial="${DEVPROP[ro.boot.serialno]}"
    elif [[ -n "$SERIAL" ]]; then
      serial="${SERIAL}"
    else
      [[ $(adb devices |grep "device$" |wc -l) -eq 1 ]] && serial="$(adb devices |grep "device$"|awk '{print $1}')"
    fi
  }
  echo "* Serial: ${serial}" >> "$devicedoc"                                    # 015d3c26a420000a
  serial="${DEVPROP[gsm.baseband.imei]}"
  [[ -z "$serial" ]] && serial="$(adb ${ADBOPTS} shell dumpsys iphonesubinfo | grep -i "device id" | awk '{print $NF}' | sed 's/\r//g')"
  [[ -n "$serial" ]] && echo "* IMEI: $serial" >> "$devicedoc"
  [[ -n "${DEVPROP[ro.board.platform]}" ]] && echo "* Platform: ${DEVPROP[ro.board.platform]}" >> "$devicedoc" # omap3
  [[ -n "${DEVPROP[ro.radio.hw.version]}" ]] && echo "* Radio version: ${DEVPROP[ro.radio.hw.version]}" >> "$devicedoc" # SJUG5980AA
  [[ -n "${DEVPROP[gsm.baseband.version]}" ]] && echo "* Baseband: ${DEVPROP[gsm.baseband.version]}" >> "$devicedoc" # L6260_MODEM_SIC_02.1233.00
  [[ -n "${DEVPROP[wlan.chip.vendor]}${DEVPROP[wlan.chip.version]}" ]] && echo "* WiFi vendor / version: ${DEVPROP[wlan.chip.vendor]} / ${DEVPROP[wlan.chip.version]}" >> "$devicedoc" # brcm / bcm4330x
  echo "* CPU: ${DEVPROP[ro.product.cpu.abi]}" >> "$devicedoc"                  # ro.product.cpu.abi=armeabi-v7a
  echo "* Screen density: ${DEVPROP[ro.sf.lcd_density]}" >> "$devicedoc"        # ro.sf.lcd_density=240
  echo >> "$devicedoc"

  if [[ ${MK_DEVICEINFO_SENSORS} -gt 0 ]]; then
    doProgress "   + checking for sensor details" 3
    if [[ "$(adb ${ADBOPTS} shell dumpsys sensorservice | wc -l)" -gt 1 ]]; then # make sure sensorservice is available
      echo "### Sensors" >> "$devicedoc"
      adb ${ADBOPTS} shell dumpsys sensorservice > $tmp
      while read zeile; do
        left="${zeile#*|}"
        left="${zeile%%\|*}"
        left="${left%"${left##*[![:space:]]}"}" # remove trailing spaces
        right="${zeile%\|*}"
        right="${right#*\|}"
        right="${right%%\|*}"
        right="${right%"${right##*[![:space:]]}"}"
        [[ "$right" = "$left" ]] && continue
        if [[ -z "${right//[[:space:]]/}" ]]; then
          echo "* ${left}" >> "$devicedoc"
        else
          echo "* ${left} (${right//[[:space:]]/})" >> "$devicedoc"
        fi
      done < "${tmp}"
      echo >> "$devicedoc"
    fi
  fi

  doProgress "   + checking for OS details" 3
  echo "### OS details" >> "$devicedoc"
  echo "* SDK/Android version: ${DEVPROP[ro.build.version.sdk]}/${DEVPROP[ro.build.version.release]}" >> "$devicedoc" # 16/4.1.2
  [[ -n "${DEVPROP[ro.modversion]}" ]] && echo "* Mod: ${DEVPROP[ro.modversion]}" >> "$devicedoc" # ro.modversion=10-20121228-NIGHTLY-milestone2
  [[ -n "${DEVPROP[ro.build.id]}" ]] && echo "* BuildID: ${DEVPROP[ro.build.id]}" >> "$devicedoc" # JZO54K
  echo "* Fingerprint: ${DEVPROP[ro.build.fingerprint]}" >> "$devicedoc" # MOTO/A953_O2DE/milestone2:2.3.6/4.5.1-134_DFP-132/1317968148:user/release-keys
  echo "* Factory language: ${DEVPROP[ro.product.locale.language]}_${DEVPROP[ro.product.locale.region]}" >> "$devicedoc" # en_US
  echo "* Configured language: ${DEVPROP[persist.sys.language]}_${DEVPROP[persist.sys.country]}" >> "$devicedoc" # de_DE
  echo "* Configured timezone: ${DEVPROP[persist.sys.timezone]}" >> "$devicedoc" # Europe/Berlin
  echo >> "$devicedoc"

  # pm list features
  if [[ ${MK_DEVICEINFO_PMLISTFEATURES} -gt 0 ]]; then
    doProgress "- Evaluating 'pm list features'" 2
    echo  >> "$devicedoc"
    echo "## Device features" >> "$devicedoc"
    echo -e "\`pm list features\`:\n" >> "$devicedoc"
    for feature in $(adb ${ADBOPTS} shell "pm list features"); do
      feature=${feature//[$'\r\n']}
      echo "* ${feature#*:}" >> "$devicedoc"
    done
  fi

  # device status
  if [[ ${MK_DEVICEINFO_STATUS} -gt 0 ]]; then
    doProgress "- Evaluating device status" 2
    echo >> "$devicedoc"
    echo "## Device Status" >> "$devicedoc"

    doProgress "  + Battery status" 3
    echo "### Battery Status" >> "$devicedoc"
    adb ${ADBOPTS} shell dumpsys battery > $tmp
    local battstat=(none unknown charging discharging "not charging" full)
    local batthealth=(none unknown good overheat dead overvoltage "unspecified failure" cold)
    while IFS='' read zeile; do
      [[ "${zeile:0:1}" != " " ]] && continue # skip header
      zeile="${zeile//[$'\t\r\n']}"
      right="${zeile#*:}"
      [[ "${right:0:1}" = " " ]] && right="${right:1}"
      left="${zeile%:*}"
      left="${left#"${left%%[![:space:]]*}"}" # remove leading spaces
      case "$left" in
        "status") echo "* ${left}: ${right} (${battstat[${right}]})"  >> "$devicedoc" ;;
        "health") echo "* ${left}: ${right} (${batthealth[${right}]})"  >> "$devicedoc" ;;
        *)        echo "* ${left}: ${right}"  >> "$devicedoc" ;;
      esac
    done < "${tmp}"

    doProgress "  + Radio status" 3
    echo >> "$devicedoc"
    echo "### Radio Status" >> "$devicedoc"
    declare -A radio
    adb ${ADBOPTS} shell dumpsys telephony.registry|grep "=" > $tmp
    local callstate=(idle ringing off-hook)
    local servicestate=(service "out of service" "emergency only" "powered off")
    local dataactivity=(none in out inout)
    local dataconnectionstate=(disconnected connecting connected suspended)
    while IFS='' read zeile; do
      zeile="${zeile//[$'\t\r\n']}"
      zeile="${zeile#"${zeile%%[![:space:]]*}"}"
      radio[${zeile%%=*}]="${zeile#*=}"
    done < "${tmp}"
    echo "* Signal strength: [${radio[mSignalStrength]}](http://android.stackexchange.com/a/74954/16575)" >> "$devicedoc"
    echo "* Service state: ${radio[mServiceState]:0:1} (${servicestate[${radio[mServiceState]:0:1}]})" >> "$devicedoc"
    echo "* Call state: ${radio[mCallState]} (${callstate[${radio[mCallState]}]})" >> "$devicedoc"
    echo "* Call forwarding active: ${radio[mCallForwarding]}" >> "$devicedoc"
    if [[ "${radio[mDataConnectionPossible]}" = "false" ]]; then
      echo "* Data connection possible: ${radio[mDataConnectionPossible]} (${radio[mDataConnectionReason]})" >> "$devicedoc"
    else
      echo "* Data connection possible: ${radio[mDataConnectionPossible]}" >> "$devicedoc"
      left="${radio[mDataActivity]}"
      echo "* Data activity: ${radio[mDataActivity]} (${dataactivity[${radio[mDataActivity]}]})" >> "$devicedoc"
      if [[ -n "${radio[mDataConnectionState]}" ]]; then
        echo "* Data connection state: ${radio[mDataConnectionState]} (${dataconnectionstate[${radio[mDataConnectionState]}]})" >> "$devicedoc"
      elif [[ -n "${radio[mActiveDataConnectionState]}" ]]; then
        echo "* Data connection state: ${radio[mActiveDataConnectionState]} (${dataconnectionstate[${radio[mActiveDataConnectionState]}]})" >> "$devicedoc"
      fi
      [[ -n "${radio[mDataConnectionApn]}" ]] && echo "* Current APN: ${radio[mDataConnectionApn]}" >> "$devicedoc"
    fi
  fi

  doProgress "  + networking details" 3
  echo "### Networking details" >> "$devicedoc"
  [[ -n "${DEVPROP[wifi.interface]}" ]] && echo "* WiFi Interface: ${DEVPROP[wifi.interface]}" >> "$devicedoc"
  [[ -n "${DEVPROP[net.dns1]}${DEVPROP[net.dns2]}" ]] && echo "* Default DNS server: ${DEVPROP[net.dns1]} / ${DEVPROP[net.dns2]}" >> "$devicedoc"
  echo "* WiFi driver status: ${DEVPROP[wlan.driver.status]}" >> "$devicedoc"
  echo "* WiFi scan interval: ${DEVPROP[wifi.supplicant_scan_interval]}" >> "$devicedoc"
  [[ -n "${DEVPROP[dhcp.wlan0.dns1]}" ]] && echo "* WiFi DHCP DNS: ${DEVPROP[dhcp.wlan0.dns1]} / ${DEVPROP[dhcp.wlan0.dns2]} / ${DEVPROP[dhcp.wlan0.dns3]}" >> "$devicedoc"
  [[ -n "${DEVPROP[dhcp.wlan0.gateway]}" ]] && echo "* WiFi default gateway: ${DEVPROP[dhcp.wlan0.gateway]}" >> "$devicedoc"
  [[ -n "${DEVPROP[dhcp.wlan0.ipaddress]}" ]] && echo "* WiFi IP: ${DEVPROP[dhcp.wlan0.ipaddress]}" >> "$devicedoc"
  [[ -n "${DEVPROP[mobiledata.interfaces]}" ]] && echo "* Mobile data interfaces: ${DEVPROP[mobiledata.interfaces]}" >> "$devicedoc"
  echo >> "$devicedoc"

  # Storage
  doProgress "  + storage details" 3
  echo "### Storage details" >> "$devicedoc"
  [[ -n "${DEVPROP[EXTERNAL_STORAGE_MOUNT]}" ]] && echo "* Internal SD mount point: ${DEVPROP[EXTERNAL_STORAGE_MOUNT]}" >> "$devicedoc"
  [[ -n "${DEVPROP[EXTERNAL_ADD_STORAGE_MOUNT]}" ]] && echo "* External SD mount point: ${DEVPROP[EXTERNAL_ADD_STORAGE_MOUNT]}" >> "$devicedoc"
  [[ -n "${DEVPROP[ro.crypto.fuse_sdcard]}" ]] && echo "* Internal SD via FUSE: ${DEVPROP[ro.crypto.fuse_sdcard]}" >> "$devicedoc"
  [[ -n "${DEVPROP[ro.crypto.state]}" ]] && echo "* Storage encrypted: ${DEVPROP[ro.crypto.state]}" >> "$devicedoc"
  [[ ${MK_PARTINFO} -gt 0 ]] && writePartInfo "$devicedoc"
  echo "* Disk statistics:" >> "$devicedoc"
  adb ${ADBOPTS} shell dumpsys diskstats > ${tmp}
  while read zeile; do
    echo -e "    * ${zeile/// }" >> "$devicedoc"
  done < ${tmp}

  if [[ -n "${DEVPROP[gsm.operator.alpha]}" ]]; then # Provider info
    doProgress "  + Provider info" 3
    echo >> "$devicedoc"
    echo "### Provider info" >> "$devicedoc"
    echo "* Mobile provider: ${DEVPROP[gsm.operator.alpha]}" >> "$devicedoc"
    [[ -n "${DEVPROP[gsm.operator.iso-country]}" ]] && echo "* Provider country: ${DEVPROP[gsm.operator.iso-country]}" >> "$devicedoc"
    [[ -n "${DEVPROP[gsm.operator.numeric]}" ]] && echo "* Provider code: ${DEVPROP[gsm.operator.numeric]}" >> "$devicedoc"
    [[ -n "${DEVPROP[gsm.sim.state]}" ]] && echo "* SIM state: ${DEVPROP[gsm.sim.state]}" >> "$devicedoc"
  fi


  # ADB calls for the next two blocks must be made with default IFS or will fail
  doProgress "- Obtaining account and backup details" 2
  local accs=$(adb ${ADBOPTS} shell dumpsys account|grep " Account "|sed 's/[\{\}\r]//g'|awk '{$1=""; print $0}')
  adb ${ADBOPTS} shell dumpsys backup | sed 's/\r//g' > "$tmp"

  echo >> "$devicedoc"
  echo "## Configured accounts" >> "$devicedoc"
  OIFS="${IFS}"
  IFS="
"
  for acc in $accs; do
    echo "* ${acc}" >> "$devicedoc"
  done

  echo >> "$devicedoc"
  echo "## Google Cloud Backup" >> "$devicedoc"
  echo "* $(grep 'Backup Manager is' "$tmp")" >> "$devicedoc"
  echo "* $(grep 'Auto-restore is' "$tmp")" >> "$devicedoc"
  echo "* Backup destinations:" >> "$devicedoc"
  for dest in $(grep "destination:" "$tmp"|awk '{$1=""; print $0}'); do
    echo "    - ${dest}" >> "$devicedoc"
  done
  echo "* $(grep 'Last backup pass' "$tmp")" >> "$devicedoc"
  echo "* $(grep 'Ever backed up:' "$tmp")" >> "$devicedoc"
  echo "* $(grep 'Pending backup:' "$tmp")" >> "$devicedoc"
  echo "* Participants:" >> "$devicedoc"
  for zeile in $(grep -A1 "uid:" "$tmp"|awk '{print $1}'); do
    case "$zeile" in
      "uid:"|"--") ;;
      *) echo "    - ${zeile}" >> "$devicedoc" ;;
    esac
  done
  rm "$tmp"

  IFS="${OIFS}"
}


#
# Collect app details via dumpsys
#
getAppDetails() {
  local P_BLOCK="none" # none|pkglist|pkg|disabled|enabled|perms
  local P_PKGNAME=""   # name of the currently processed package
  local tmpstring=""
  local P_SKIP=(userId sharedUser pkg resourcePath nativeLibraryPath versionCode targetSdk timeStamp signatures permissionsFixed pkgFlags applicationInfo)
  declare -A PK_CODEPATH
  declare -A PK_VERSION
  declare -A PK_DATADIR
  declare -A PK_SCREENSIZE
  declare -A PK_FIRSTINSTALL
  declare -A PK_LASTUPDATE
  declare -A PK_INSTALLERS    # per source
  PK_INSTALLERS[none]="unknown source"
  declare -A PK_INSTALLER     # per app
  declare -A PK_DISABLED      # list of components separated by spaces
  declare -A PK_FLAGS         # flags=[ SYSTEM HAS_CODE ALLOW_TASK_REPARENTING ALLOW_CLEAR_USER_DATA ALLOW_BACKUP LARGE_HEAP ]
  declare -A PK_USERS         # User 0:  installed=true stopped=false notLaunched=false enabled=0
  declare -A APP_INSTALL_SRC
  APP_INSTALL_SRC[org.fdroid.fdroid]="F-Droid"
  APP_INSTALL_SRC[cm.aptoide.pt]="Aptoide"
  APP_INSTALL_SRC[com.android.vending]="Google Play"
  APP_INSTALL_SRC[com.google.android.feedback]="Google Play (Feedback)"
  local PKGDUMP=$(tempfile)
  trap "rm -f -- '$PKGDUMP'" RETURN
  local SH_DISABLED="${OUTDIR}/deadReceivers.sh"

  doProgress "Generating app detail info"
  doProgress "- collecting data via dumpsys" 2
  adb ${ADBOPTS} shell "dumpsys package" |egrep -A99999 "^Packages:" |egrep -B99999 "^Shared users:" > "${PKGDUMP}"

  # Parsing dump
  doProgress "- parsing package dump" 2
  while IFS='' read zeile; do # no idea why, but some dump lines are terminated using CRLF
    case ${P_BLOCK} in
      none)
        [[ "$zeile" != "Packages:" ]] && continue;
        P_BLOCK="pkglist"
        doProgress "  - Found package list marker" 4
        continue;
        ;;

      pkglist)
        if [[ "${zeile:0:11}" = "  Package [" ]]; then  # "  Package [com.google.android.location] (40e85638):"
          tmpstring="${zeile##*[}"                      # strip leading
          P_PKGNAME="${tmpstring%%]*}"                  # strip trailing
          P_BLOCK="pkg"
          doProgress "  - Package: $P_PKGNAME" 4
          continue
        fi
        ;;

      pkg)
        tmpstring="${zeile%%=*}"
        tmpstring="${tmpstring##*[[:space:]]}"
        in_array $tmpstring "${P_SKIP[@]}" && continue
        [[ "$zeile" = "    grantedPermissions:" ]] && continue
        [[ "${zeile:0:6}" = "      " ]] && continue
        [[ -z "${zeile%%* }" ]] && break # end of package list is an empty line, sometimes with spaces
        case "$tmpstring" in
          "codePath")
            PK_CODEPATH[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +codePath: ${PK_CODEPATH[$P_PKGNAME]}" 5
            continue
            ;;
          "versionName")
            PK_VERSION[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +version: ${PK_VERSION[$P_PKGNAME]}" 5
            continue
            ;;
          "dataDir")
            PK_DATADIR[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +data: ${PK_DATADIR[$P_PKGNAME]}" 5
            continue
            ;;
          "supportsScreens")
            PK_SCREENSIZE[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +screens: ${PK_SCREENSIZE[$P_PKGNAME]}" 5
            continue
            ;;
          "firstInstallTime")
            PK_FIRSTINSTALL[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +firstinst: ${PK_FIRSTINSTALL[$P_PKGNAME]}" 5
            continue
            ;;
          "lastUpdateTime")
            PK_LASTUPDATE[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +lastup: ${PK_LASTUPDATE[$P_PKGNAME]}" 5
            continue
            ;;
          "installerPackageName")
            in_array "${zeile##*=}" "${PK_INSTALLERS[@]}" || { # setting up "used sources" to group by
              if [ -z "${APP_INSTALL_SRC[${zeile##*=}]}" ]; then
                PK_INSTALLERS[${zeile##*=}]="${zeile##*=}"
              else
                PK_INSTALLERS[${zeile##*=}]="${APP_INSTALL_SRC[${zeile##*=}]}"
              fi
            }
            PK_INSTALLER[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +installer: ${PK_INSTALLER[$P_PKGNAME]}" 5
            continue
            ;;
          "flags")
            PK_FLAGS[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +flags: ${PK_FLAGS[$P_PKGNAME]}" 5
            continue
            ;;
          *)
            if [[ "${zeile:0:11}" = "  Package [" ]]; then  # "  Package [com.google.android.location] (40e85638):"
              tmpstring="${zeile##*[}"                      # strip leading
              P_PKGNAME="${tmpstring%%]*}"                  # strip trailing
              doProgress "  - Package: $P_PKGNAME" 4
              continue
            fi
            if [[ "${zeile}" = "    disabledComponents:" ]]; then
              P_BLOCK="disabled"
              continue
            fi
            if [[ "${zeile}" = "    enabledComponents:" ]]; then
              P_BLOCK="enabled"
              continue
            fi
            if [[ "${zeile:0:8}" = "    User" ]]; then  # Android 4.2+ MultiUser info
              # '    User 0:  installed=true stopped=false notLaunched=false enabled=0'
              if [[ -z "${PK_USERS[$P_PKGNAME]}" ]]; then
                PK_USERS[$P_PKGNAME]="    + ${zeile:4}"
              else
                PK_USERS[$P_PKGNAME]+="\n    + ${zeile:4}"
              fi
              continue
            fi

            oops "pkg" "${LINENO}" "Unexpected: '$zeile'" 2
            ;;
        esac
        ;;

      "disabled") # disabled components of current pkg
        if [[ "${zeile:0:6}" = "      " ]]; then
          if [[ -z "${PK_DISABLED[$P_PKGNAME]}" ]]; then
            PK_DISABLED[$P_PKGNAME]="${zeile:6}"
          else
            PK_DISABLED[$P_PKGNAME]="${PK_DISABLED[$P_PKGNAME]} ${zeile:6}"
          fi
          continue
        fi
        if [[ "${zeile}" = "    grantedPermissions:" ]]; then
          P_BLOCK="perms"
          continue
        fi
        if [[ "${zeile}" = "    enabledComponents:" ]]; then
          P_BLOCK="enabled"
          continue
        fi
        if [[ "${zeile:0:11}" = "  Package [" ]]; then  # "  Package [com.google.android.location] (40e85638):"
          tmpstring="${zeile##*[}"                      # strip leading
          P_PKGNAME="${tmpstring%%]*}"                  # strip trailing
          P_BLOCK="pkg"
          doProgress "  - Package: $P_PKGNAME" 4
          continue
        fi

        oops "disabled" "${LINENO}" "$zeile" 2
        ;;

      "enabled") # enabled components of current pkg
        if [[ "${zeile:0:6}" = "      " ]]; then
          continue # we don't include enabled components
        fi
        if [[ "${zeile}" = "    grantedPermissions:" ]]; then
          P_BLOCK="perms"
          continue
        fi
        if [[ "${zeile:0:11}" = "  Package [" ]]; then  # "  Package [com.google.android.location] (40e85638):"
          tmpstring="${zeile##*[}"                      # strip leading
          P_PKGNAME="${tmpstring%%]*}"                  # strip trailing
          P_BLOCK="pkg"
          doProgress "  - Package: $P_PKGNAME" 4
          continue
        fi

        oops "enabled" "${LINENO}" "$zeile" 2
        ;;

      "perms")
        if [[ "${zeile:0:6}" = "      " ]]; then
          continue # we don't include permissions (yet)
        fi
        if [[ "${zeile:0:11}" = "  Package [" ]]; then  # "  Package [com.google.android.location] (40e85638):"
          tmpstring="${zeile##*[}"                      # strip leading
          P_PKGNAME="${tmpstring%%]*}"                  # strip trailing
          P_BLOCK="pkg"
          doProgress "  - Package: $P_PKGNAME" 4
          continue
        fi

        oops "perms" "${LINENO}" "$zeile" 2
        ;;
      *)
        ;;
    esac

  done < "${PKGDUMP}"

  # Create userApps.md
  doProgress "- generating userApps.md" 2
  local mdfile="${DOCDIR}/userApps.md"

  echo "# Installed User-Apps on ${DEVICE_NAME}" > "${mdfile}"
  echo "(As of $(date '+%Y-%m-%d %H:%M'))" >> "${mdfile}"
  echo -e "#!/bin/bash\n# Disable Components (${DEVICE_NAME})" > "${SH_DISABLED}"
  declare -A PK_INFO
  for src in ${!PK_INSTALLERS[@]}; do
    PK_INFO[$src]=""
  done
  local CUR_INSTALLER
  local APPNAME
  for app in ${userApps[@]}; do
    APPNAME=$(getAppname "$app")
    if [[ -z "${PK_INSTALLER[$app]}" ]]; then # no installer
      if [[ "${APPNAME}" = "${app}" ]]; then
        tmpstring="+ $app\n"
      else
        tmpstring="+ ${APPNAME} (${app})\n"
      fi
    elif [[ -n "${APP_MARKET_URL[${PK_INSTALLER[$app]}]}" ]]; then
      tmpstring="+ [${APPNAME}](${APP_MARKET_URL[${PK_INSTALLER[$app]}]/\%s/$app})\n"
    else # no web source
      if [[ "${APPNAME}" = "${app}" ]]; then
        tmpstring="+ $app\n"
      else
        tmpstring="+ ${APPNAME} (${app})\n"
      fi
    fi
    [[ -n "${PK_FIRSTINSTALL[$app]}" ]] && tmpstring+="    + first installed: ${PK_FIRSTINSTALL[$app]}\n"
    [[ -n "${PK_LASTUPDATE[$app]}" ]]   && tmpstring+="    + last updated: ${PK_LASTUPDATE[$app]}\n"
    [[ -n "${PK_VERSION[$app]}" ]]      && tmpstring+="    + installed version: ${PK_VERSION[$app]}\n"
    [[ -n "${PK_CODEPATH[$app]}" ]]     && tmpstring+="    + CodePath: \`${PK_CODEPATH[$app]}\`\n"
    [[ -n "${PK_DATADIR[$app]}" ]]      && tmpstring+="    + App data: \`${PK_DATADIR[$app]}\`\n"
    [[ -n "${PK_SCREENSIZE[$app]}" ]]   && tmpstring+="    + supported screen sizes: ${PK_SCREENSIZE[$app]}\n"
    [[ -n "${PK_FLAGS[$app]}" ]]        && tmpstring+="    + flags: ${PK_FLAGS[$app]}\n"
    [[ -n "${PK_USERS[$app]}" ]]        && tmpstring+="${PK_USERS[$app]}\n"
    [[ -n "${PK_DISABLED[$app]}" ]]     && {
      tmpstring+="    + disabled components:\n"
      echo "" >> "${SH_DISABLED}"
      for comp in ${PK_DISABLED[$app]}; do
        tmpstring+="        - $comp\n"
        echo "adb shell \"pm disable ${app}/${comp}\"" >> "${SH_DISABLED}"
      done
    }
    if [[ -z "${PK_INSTALLER[$app]}" ]]; then
      PK_INFO[none]+="$tmpstring\n"
    else
      CUR_INSTALLER="${PK_INSTALLER[$app]}"
      PK_INFO[$CUR_INSTALLER]+="$tmpstring\n"
    fi
  done
  for src in ${!PK_INSTALLERS[@]}; do
    echo -e "## Installed from ${PK_INSTALLERS[$src]} (installer: $src)\n" >> "${mdfile}"
    echo -e "${PK_INFO[$src]}\n" >> "${mdfile}"
  done

  doProgress "- checking for disabled system components" 2
  echo -e "\n\n# Disable System Components" >> "${SH_DISABLED}"
  for app in ${sysApps[@]}; do
    [[ -n "${PK_DISABLED[$app]}" ]]     && {
      echo "" >> "${SH_DISABLED}"
      for comp in ${PK_DISABLED[$app]}; do
        echo "adb shell \"pm disable ${app}/${comp}\"" >> "${SH_DISABLED}"
      done
    }
  done

  doProgress "- removing temporary dumpfile" 2
  rm -f "${PKGDUMP}"
}


#
# Post processing
#
postProcess() {
  doProgress "PostProcessing and Cleanup"
  if [[ $TIMESTAMPED_SUBDIRS -gt 0 ]]; then
    if [[ $LINK_LATEST_SUBDIR -gt 0 ]]; then
      doProgress "- symlink latest generation" 2
      local LINK_NAME="$(dirname "${OUTDIR}")/latest"
      if [ -L "${LINK_NAME}" -o ! -e "${LINK_NAME}" ]; then
        rm -f "${LINK_NAME}" > /dev/null 2>&1
        ln -sf "$(basename "${OUTDIR}")" "${LINK_NAME}"
      else
        doProgress "$(ansi_code "! Cannot symlink latest generation subdir: some file/directory already uses its name" "red")"
      fi

      if [[ ${KEEP_SUBDIR_GENERATIONS} -gt 0 ]]; then
        doProgress "- remove outaged generations" 2
        declare -a GENS
        cd "$(dirname ${OUTDIR})"
        for d in $(ls -dpX [0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]); do
          [[ ${#d} -ne 13 ]] && continue
          GENS+=($d)
        done
        declare -i counter=0
        if [[ ${#GENS[@]} -gt ${KEEP_SUBDIR_GENERATIONS} ]]; then
          local HAVE_BACKUPS
          local files
          while [[ ${#GENS[@]} -gt ${KEEP_SUBDIR_GENERATIONS} ]]; do
            # We do not want to delete real backups, so make sure there are none
            HAVE_BACKUPS=0
            files=(${GENS[${counter}]:0:12}/${USERDIR}/*) # UserApps
            [[ -e "${files[0]}" ]] && HAVE_BACKUPS=1
            files=(${GENS[${counter}]:0:12}/${SYSDIR}/*)  # SysApps
            [[ -e "${files[0]}" ]] && HAVE_BACKUPS=1
            files=(${GENS[${counter}]:0:12}/*.ab)         # Any ADB backups
            [[ -e "${files[0]}" ]] && HAVE_BACKUPS=1
            files=(${GENS[${counter}]:0:12}/*.gz)         # Any .gz archives, e.g. converted by ab2tar
            [[ -e "${files[0]}" ]] && HAVE_BACKUPS=1
            if [[ $HAVE_BACKUPS -eq 0 ]]; then
              doProgress "  + removing '${GENS[${counter}]:0:12}'" 3
              rm -rf "${GENS[${counter}]:0:12}"
            else
              warning="  + '${GENS[${counter}]:0:12}' seems to contain backups. Renaming it to '${GENS[${counter}]:0:12}.Backup'"
              echo -e "$(ansi_code "$warning" "red")"
              mv "${GENS[${counter}]:0:12}" "${GENS[${counter}]:0:12}.Backup"
            fi
            unset GENS[${counter}]
            counter+=1
          done
        fi
        cd - >/dev/null
      fi
    fi
  fi

  if [[ -n "${POSTRUN_CMD}" ]]; then
    doProgress "- executing post-run command" 2
    $(${POSTRUN_CMD})
  fi
}


############################################[ Main ]###
echo
doProgress "$(ansi_code "Adebar running:" "bold")"
initAppLists
getDisabled
getUserAppBackup
getSystemAppBackup
getInstallLoc
[[ $((${MK_PARTINFO} + ${MK_PARTBACKUP})) -gt 0 ]] && getPartInfo
[[ ${MK_PARTBACKUP} -gt 0 ]] && writePartDumpScript
getDeviceInfo
[[ $PULL_SETTINGS -eq 1 ]] && getSettings
[[ $MK_TIBU -eq 1 ]] && getTibu
[[ $MK_PKG_DATA -ne 0 ]] && getAppDetails
postProcess
doProgress "$(ansi_code "Adebar done." "bold")"
echo

exit 0


######################################[ References ]###
# pm list packages [options] <FILTER>
# options:
#    -f: See their associated file.
#    -d: Filter to only show disabled packages.
#    -e: Filter to only show enabled packages.
#    -s: Filter to only show system packages.
#    -3: Filter to only show third party packages.
#    -i: See the installer for the packages.
#    -u: Also include uninstalled packages.
#    --user <USER_ID>: The user space to query.
#
# disable a component (e.g. BroadcastReceiver): pm disable com.example.com.testapp/.TestActivity
#
# adb pull /data/system/packages.list packages.list
# apps with UID/GID and app path
