#!/bin/bash
# Adebar
# (Android DEvice Backup And Restore)
# Creating scripts to backup and restore your apps, settings, and more
# Â© 2014 by Andreas Itzchak Rehberg
# Licensed using GPLv2 (see the file LICENSE which should have shipped with this)

# check parameters
if [ -z "$1" ]; then
  echo "Syntax: $0 <target_directory> [suffix]"
  exit 1
else
  OUTDIR="$1"
fi

# #################################[ Configuration ]###
#OUTDIR='.' # OUTDIR is specified via command line (mandatory parameter)
USERDIR="userApps"
SYSDIR="sysApps"
DOCDIR="docs"
CONFDIR="conf"
DEVICE_IP=
TIBU_PORT="8080"
TIBU_SDINT="/storage/INTERNAL/Storage-ALL.zip"
TIBU_SDEXT="/storage/SAMSUNG_EXT_SD_CARD/Storage-ALL.zip"
TIBU_BACKUPS="/TitaniumBackup-ALL.zip"
STORAGE_BASE=

# Features
MK_APPDISABLE=1
MK_USERBACKUP=1
MK_SYSBACKUP=1
PULL_SETTINGS=1
MK_TIBU=1
MK_PKG_DATA=1
MK_INSTALLLOC=1
MK_DEVICEINFO=1

# Misc
PROGRESS=1


############################################[ Init ]###
BINDIR="${0%/*}"

# Checking for config file and sourcing it, if exists
if [ -d "${BINDIR}/config" ]; then
  if [ -f "${BINDIR}/config/$OUTDIR" ]; then # device-specific config
    . "${BINDIR}/config/$OUTDIR"
  elif [ -f "${BINDIR}/config/default" ]; then # default config
    . "${BINDIR}/config/default"
  fi
elif [ -f "${BINDIR}/config" ]; then # default config as of v3
  . "${BINDIR}/config"
fi

# check whether output directory shall have a suffix
if [ -n "$2" ]; then
  OUTDIR="${OUTDIR}${2}"
fi

# Check whether a device is connected at all and, if configured, the serial matches
# No device connected:
ADBOPTS=""
if [ -z "$(adb devices|egrep "^[0-9A-Za-z]+\s+device$"|awk '{print $1}')" ]; then
  echo "No device found. Make sure you have connected your device with"
  echo "USB debugging enabled, and try again."
  echo
  exit 2
fi

serials=($(adb devices|egrep "^[0-9A-Za-z]+\s+device$"|awk '{print $1}'))
# Multiple devices connected but no serial defined:
if [ -z "${SERIAL}" -a ${#serials[*]} -ne 1 ]; then
  echo "There are currently multiple devices connected, and we don't know"
  echo "which one to connect to. Please either disconnect all but the device"
  echo "you wish to retrieve data from, or specify its serial in your"
  echo "Configuration. Then try again."
  echo
  exit 3
fi

# SERIAL specified:
if [ -n "${SERIAL}" ]; then
  if [ ${#serials[*]} -eq 1 -a "${serial[0]}" != "${SERIAL}" ]; then
    echo "Your configuration specifies a serial of '${SERIAL}',"
    echo "but the connected device presents '${serial[0]}'."
    echo "Please check if you have the correct device connected, or might have"
    echo "specified the wrong parameter to the script."
    echo ""
    exit 4
  fi
  if [ ${#serials[*]} -gt 1 ]; then
    typeset -i ser=0
    for d in ${serials[*]}; do
      [ "$d" = "${SERIAL}" ] && {
        ser=1
        break
      }
    done
    if [ $ser -eq 0 ]; then
      echo "Your configuration specifies a device serial of '${SERIAL}'."
      echo "Though multiple devices seem to be connected, that is not one"
      echo "of them. Please check and try again."
      echo ""
      exit 4
    fi
  fi
  ADBOPTS="-s ${SERIAL}"
fi


# Check output directory and create it if it does not exist
if [ -n "${STORAGE_BASE}" ]; then
  OUTDIR="${STORAGE_BASE}/${OUTDIR}"
fi
DOCDIR="${OUTDIR}/${DOCDIR}"
CONFDIR="${OUTDIR}/${CONFDIR}"
PKGXML="${CONFDIR}/packages.xml"
BUILDPROP="${CONFDIR}/build.prop"
if [ ! -d "${DOCDIR}" ]; then
  mkdir -p "${DOCDIR}" || {
    echo "Output directory does not exist, and I cannot create it. Sorry."
    echo
    exit 5
  }
  mkdir -p "${CONFDIR}"
fi

declare -a userApps # list of package names
declare -a sysApps
declare -a dApps


#########################################[ Helpers ]###
# Log progress (if enabled)
# Call: doProgress "what to show" [level]"
# level defaults to 1
doProgress() {
  [[ $PROGRESS -eq 0 ]] && return
  if [[ -z "$2" ]]; then
    local level=1
  else
    local level=$2
  fi
  if [[ $PROGRESS -ge $level ]]; then
    echo -e "$1"
  fi
}

# Helper: Check whether $needle is contained in $haystack[]
# Call it like: in_array $tmpstring "${P_SKIP[@]}"
in_array() {
    local hay needle=$1
    shift
    for hay; do
        [[ $hay == $needle ]] && return 0
    done
    return 1
}


#
# Gather lists of installed apps
#
initAppLists() {
  [[ $(($MK_USERBACKUP + $MK_SYSBACKUP)) -eq 0 ]] && return
  doProgress "Gathering lists of installed apps"

  doProgress "- userApps" 2
  for app in $(adb ${ADBOPTS} shell pm list packages -3); do
    app=${app//[$'\t\r\n']} # remove trailing CR (^M)
    userApps+=(${app##*:})
  done
  doProgress "- systemApps" 2
  for app in $(adb ${ADBOPTS} shell pm list packages -s); do
    app=${app//[$'\t\r\n']}
    sysApps+=(${app##*:})
  done
  doProgress "- checking for uninstalled apps remembered by the system" 2
  for app in $(adb ${ADBOPTS} shell pm list packages -u); do
    app=${app//[$'\t\r\n']}
    in_array "${app##*:}" ${sysApps[@]} && continue
    in_array "${app##*:}" ${userApps[@]} && continue
    dApps+=($app)
    echo "Removed app: ${app##*:}"
  done
}


#
# Create script for disabled apps
#
getDisabled() {
  [ $MK_APPDISABLE -ne 1 ] && return

  doProgress "Obtaining list of disabled apps"

  local scriptname="${OUTDIR}/disable"
  echo "#!/bin/bash" > "${scriptname}"
  echo "# Disabled apps as of $(date '+%Y-%m-%d %H:%M')" >> "${scriptname}"
  echo >> "${scriptname}"

  for app in $(adb ${ADBOPTS} shell "pm list packages -d"); do
    app=${app//[$'\t\r\n']}
    echo "adb ${ADBOPTS} shell \"pm disable ${app##*:}\"" >> "${scriptname}"
  done

  chmod u+x "${scriptname}"
}


#
# Create script to backup all user-apps
#
getUserAppBackup() {
  [ $MK_USERBACKUP -ne 1 ] && return

  doProgress "Creating backup/restore scripts for UserApps"

  local backupscript="$OUTDIR/userbackup"
  local restorescript="$OUTDIR/userrestore"
  echo "#!/bin/bash" > "$backupscript"
  echo "# Backup script as of $(date '+%Y-%m-%d %H:%M')" >> "$backupscript"
  echo "# Backs up all user apps including their .apk files and data" >> "$backupscript"
  echo "# Feel free to comment out/remove apps you don't want/need to be backed up." >> "$backupscript"
  echo  >> "$backupscript"
  echo "[ ! -d \"${USERDIR}\" ] && mkdir \"${USERDIR}\"" >> "$backupscript"
  echo >> "$backupscript"

  echo "#!/bin/bash" > "$restorescript"
  echo "# Restore script as of $(date '+%Y-%m-%d %H:%M')" >> "$restorescript"
  echo "# Restores all app backups. Comment out (or delete) those you do not wish to restore." >> "$restorescript"
  echo  >> "$restorescript"

  for app in "${userApps[@]}"; do
    echo -e "adb ${ADBOPTS} backup -f \"${USERDIR}/${app}.ab\" -apk $app" >> "$backupscript"
    echo "sleep 1" >> "$backupscript" # prevent ADB daemon from being "blocked" (e.g. on LG P880)
    echo -e "adb ${ADBOPTS} restore \"${USERDIR}/${app}.ab\"" >> "$restorescript"
  done

  chmod u+x "$backupscript" "$restorescript"
}


#
# Create script to backup all system-app data
#
getSystemAppBackup() {
  [ $MK_SYSBACKUP -ne 1 ] && return

  doProgress "Creating backup/restore scripts for SytemApps"

  local backupscript="$OUTDIR/sysbackup"
  local restorescript="$OUTDIR/sysrestore"
  echo "#!/bin/bash" > "$backupscript"
  echo "# Backup script as of $(date '+%Y-%m-%d %H:%M')" >> "$backupscript"
  echo "# Backs up the data (not the .apk files) of all your system apps" >> "$backupscript"
  echo "# Feel free to comment out/remove apps you don't want/need to be backed up." >> "$backupscript"
  echo  >> "$backupscript"
  echo "[ ! -d \"${SYSDIR}\" ] && mkdir \"${SYSDIR}\"" >> "$backupscript"
  echo >> "$backupscript"

  echo "#!/bin/bash" > "$restorescript"
  echo "# Restore script as of $(date '+%Y-%m-%d %H:%M')" >> "$restorescript"
  echo -e "# Restores all system app data backups.\n# DRAGONS HERE: this might fail if you restore to a different\n# device/Android version/ROM, so be careful!\n# Comment out/delete what you do not wish to restore." >> "$restorescript"
  echo  >> "$restorescript"

  for app in "${sysApps[@]}"; do
    prep=""
    if [ "$app" = "com.android.sharedstoragebackup" ]; then # shared storage
      prep="  "
      echo >> "$backupscript"
      echo  >> "$restorescript"
      echo -e "echo \"The following command will download 'shared storage' (i.e. contents of the SD card(s)).\"\necho \"This might take quite a while, depending on what you've stored there.\"" >> "$backupscript"
      echo -e "echo \"The following command will restore 'shared storage' (i.e. contents of the SD card(s)).\"\necho \"This might take quite a while, depending on how big your backup from it was.\"" >> "$restorescript"
      echo -e "read -n 1 -p \"Do you wish to run this command now? (Y/n) \" res\necho\nres=\$(echo \$res|tr [:upper:] [:lower:])\nif [ \"\$res\" = \"y\" ]; then" >> "$backupscript"
      echo -e "read -n 1 -p \"Do you wish to run this command now? (Y/n) \" res\necho\nres=\$(echo \$res|tr [:upper:] [:lower:])\nif [ \"\$res\" = \"y\" ]; then" >> "$restorescript"
    else
      prep=""
    fi
    echo -e "${prep}adb ${ADBOPTS} backup -f \"${SYSDIR}/${app}.ab\" -noapk $app" >> "$backupscript"
    echo "${prep}sleep 1" >> "$backupscript" # prevent ADB daemon from being "blocked" (e.g. on LG P880)
    echo -e "${prep}adb ${ADBOPTS} restore \"${SYSDIR}/${app}.ab\"" >> "$restorescript"
    if [ "$app" = "com.android.sharedstoragebackup" ]; then
      echo -e "else\n echo \"Skipping shared storage\"\nfi" >> "$backupscript"
      echo -e "else\n echo \"Skipping shared storage\"\nfi" >> "$restorescript"
      echo >> "$backupscript"
      echo  >> "$restorescript"
    fi
  done

  chmod u+x "$backupscript" "$restorescript"
}


#
# Retrieve packages.xml (required in different places)
#
pullPackagesXML() {
  [ ${MK_PKG_DATA} -eq 0 ] && return
  local msg="$((adb ${ADBOPTS} pull /data/system/packages.xml "${PKGXML}") 2>&1)"
  doProgress "Pulling packages.xml: $msg" 2
}


#
# Get the default install-location
#
getInstallLoc() {
  [ $MK_INSTALLLOC -ne 1 ] && return
  doProgress "Checking default install-location"
  foo="$(adb ${ADBOPTS} shell pm get-install-location)"
  echo "pm set-install-location ${foo//[^0-9]/}" > "$OUTDIR/defaultInstallLoc"
  chmod u+x "$OUTDIR/defaultInstallLoc"
}

#
# Get device info
#
getDeviceInfo() {
  [ $MK_DEVICEINFO -ne 1 ] && return
  doProgress "Collecting device information"
  local item=""
  local devicedoc="${DOCDIR}/deviceInfo.md"
  local msg=""

  echo "# Device Information" > "$devicedoc"

  msg="$((adb ${ADBOPTS} pull /system/build.prop "${BUILDPROP}") 2>&1)"
  doProgress "- Evaluating build.prop (xfer: $msg)" 2
  if [ $? -eq 0 ]; then # successfully pulled the build.prop
    echo  >> "$devicedoc"
    echo "## Device and ROM properties (from \`build.prop\` / \`getprop\`)" >> "$devicedoc"
    while read zeile; do
      zeile="${zeile//=/ }"
      foo=($zeile)
      case ${foo[0]} in
        "ro.build.version.sdk") local sdk=${foo[1]} ;;
        "ro.build.version.release") local aver=${foo[1]} ;;
        "ro.modversion") local modver=${foo[1]} ;;         # ro.modversion=10-20121228-NIGHTLY-milestone2
        "ro.product.manufacturer") local manu=${foo[1]} ;; # ro.product.manufacturer=Motorola
        "ro.product.model") local model=${foo[1]} ;;       # ro.product.model=A953
        "ro.product.device") local device=${foo[1]} ;;     # ro.product.device=milestone2
        "ro.product.cpu.abi") local cpu=${foo[1]} ;;       # ro.product.cpu.abi=armeabi-v7a
        "ro.product.locale.language") local lang=${foo[1]} ;; # ro.product.locale.language=en
        "ro.product.locale.region") local region=${foo[1]} ;; # ro.product.locale.region=US
        "ro.sf.lcd_density") local density=${foo[1]} ;;    # ro.sf.lcd_density=240
        "net.dns1") local dns1=${foo[1]} ;;                # net.dns1=8.8.8.8
        "net.dns2") local dns2=${foo[1]} ;;
      esac
    done < "${BUILDPROP}"
    local dserial="$(adb ${ADBOPTS} shell getprop ro.boot.serialno | sed 's/\r//g')"
    local dradioversion="$(adb ${ADBOPTS} shell getprop ro.radio.hw.version | sed 's/\r//g')"
    local dbaseband="$(adb ${ADBOPTS} shell getprop gsm.baseband.version | sed 's/\r//g')"
    [ -z "${dbaseband}" ] && dbaseband="$(adb ${ADBOPTS} shell getprop gsm.version.baseband | sed 's/\r//g')"
    local dplatform="$(adb ${ADBOPTS} shell getprop ro.board.platform | sed 's/\r//g')"
    local dbuildid="$(adb ${ADBOPTS} shell getprop ro.build.id | sed 's/\r//g')"
    local dwifivendor="$(adb ${ADBOPTS} shell getprop wlan.chip.vendor | sed 's/\r//g')"
    local dwifiversion="$(adb ${ADBOPTS} shell getprop wlan.chip.version | sed 's/\r//g')"
    echo "* Manufacturer: ${manu}" >> "$devicedoc"
    echo "* Model: ${model} (${device})" >> "$devicedoc"
    [ -n "${dplatform}" ] && echo "* Platform: ${dplatform}" >> "$devicedoc"
    [ -n "$dradioversion" ] && echo "* Radio version: ${dradioversion}" >> "$devicedoc"
    [ -n "$dbaseband" ] && echo "* Baseband: ${dbaseband}" >> "$devicedoc"
    [ -n "${dwifivendor}${dwifiversion}" ] && echo "* WiFi vendor / version: ${dwifivendor} / ${dwifiversion}" >> "$devicedoc"
    echo "* CPU: ${cpu}" >> "$devicedoc"
    echo "* Screen density: ${density}" >> "$devicedoc"
    echo "* SDK/Android version: ${sdk}/${aver}" >> "$devicedoc"
    [ -n "$modver" ] && echo "* Mod: ${modver}" >> "$devicedoc"
    [ -n "${dbuildid}" ] && echo "* BuildID: ${dbuildid}" >> "$devicedoc"
    echo "* Fingerprint: $(adb ${ADBOPTS} shell getprop ro.build.fingerprint | sed 's/\r//g')" >> "$devicedoc"
    [ -n "${dserial}" ] && echo "* Serial: ${dserial}" >> "$devicedoc"
    echo "* IMEI: $(adb ${ADBOPTS} shell dumpsys iphonesubinfo | grep -i "device id" | awk '{print $NF}' | sed 's/\r//g')" >> "$devicedoc"
    echo "* Factory language: ${lang}_${region}" >> "$devicedoc"
    echo "* Configured language: $(adb ${ADBOPTS} shell getprop persist.sys.language | sed 's/\r//g')_$(adb ${ADBOPTS} shell getprop persist.sys.country | sed 's/\r//g')" >> "$devicedoc"
    echo "* Configured timezone: $(adb ${ADBOPTS} shell getprop persist.sys.timezone | sed 's/\r//g')" >> "$devicedoc"
    [ -n "${dns1}${dns2}" ] && echo "* Default DNS server: ${dns1}/${dns2}" >> "$devicedoc"
    # ro.product.brand=MOTO
    # ro.product.name=A953_DFP
    # ro.product.board=milestone2
    # ro.product.cpu.abi2=armeabi
  fi

  doProgress "- Evaluating 'pm list features'" 2
  echo  >> "$devicedoc"
  echo "## Device features (\`pm list features\`)" >> "$devicedoc"
  for feature in $(adb ${ADBOPTS} shell "pm list features"); do
    feature=${feature//[$'\r\n']}
    echo "* ${feature#*:}" >> "$devicedoc"
  done

  # ADB calls for the next two blocks must be made with default IFS or will fail
  doProgress "- Obtaining details via dumpsys" 2
  local accs=$(adb ${ADBOPTS} shell dumpsys account|grep " Account "|sed 's/[\{\}\r]//g'|awk '{$1=""; print $0}')
  local tmp="./dump.$$"
  adb ${ADBOPTS} shell dumpsys backup | sed 's/\r//g' > "$tmp"

  echo >> "$devicedoc"
  echo "## Configured accounts (from \`dumpsys\`)" >> "$devicedoc"
  OIFS="${IFS}"
  IFS="
"
  for acc in $accs; do
    echo "* ${acc}" >> "$devicedoc"
  done

  echo >> "$devicedoc"
  echo "## Google Cloud Backup (from \`dumpsys\`)" >> "$devicedoc"
  echo "* $(grep 'Backup Manager is' "$tmp")" >> "$devicedoc"
  echo "* $(grep 'Auto-restore is' "$tmp")" >> "$devicedoc"
  echo "* Backup destinations:" >> "$devicedoc"
  for dest in $(grep "destination:" "$tmp"|awk '{$1=""; print $0}'); do
    echo "    - ${dest}" >> "$devicedoc"
  done
  echo "* $(grep 'Last backup pass' "$tmp")" >> "$devicedoc"
  echo "* $(grep 'Ever backed up:' "$tmp")" >> "$devicedoc"
  echo "* $(grep 'Pending backup:' "$tmp")" >> "$devicedoc"
  echo "* Participants:" >> "$devicedoc"
  for zeile in $(grep -A1 "uid:" "$tmp"|awk '{print $1}'); do
    case "$zeile" in
      "uid:"|"--") ;;
      *) echo "    - ${zeile}" >> "$devicedoc" ;;
    esac
  done
  rm "$tmp"

  IFS="${OIFS}"
}


#
# Get settings
# includes WiFi APs etc.
#
getSettings() {
  [ $PULL_SETTINGS -ne 1 ] && return
  doProgress "Pulling configuration files"

  local msg
  msg="$((adb ${ADBOPTS} pull /data/misc/wifi/wpa_supplicant.conf "${CONFDIR}/wpa_supplicant.conf") 2>&1)"
  doProgress "- wpa_supplicant.conf: $msg" 2
  msg="$((adb ${ADBOPTS} pull /system/etc/gps.conf "${CONFDIR}/gps.conf") 2>&1)"
  doProgress "- gps.conf: $msg" 2
  msg="$((adb ${ADBOPTS} pull /system/etc/hosts "${CONFDIR}/hosts") 2>&1)"
  doProgress "- hosts: $msg" 2
  # SMS/MMS ?
  # CallLog ?
  # ?
}


#
# Create script to download SDCard Contents and TiBu Backups via TiBu WebServer
#
getTibu() {
  [ $MK_TIBU -ne 1 ] && return
  [ -z "${DEVICE_IP}" ] && return
  doProgress "Creating scripts to pull stuff via TiBu"

  local scriptname="${OUTDIR}/tibu"
  echo "#!/bin/bash" > "${scriptname}"
  echo "# Download contents of external/internal SDCard and Backups via TitaniumBackups WebServer" >> "${scriptname}"
  echo "# Make sure your device is connected to your local WiFi, and you've enabled TiBu's WebServer" >> "${scriptname}"
  echo "# The latter can be done from within TiBu via the menu" >> "${scriptname}"
  echo "# As usual: comment out the components you do not want/need :)" >> "${scriptname}"
  echo  >> "${scriptname}"
  timestamp="$(date '+%Y%m%d_%H%M')"
  echo "wget -O sdinternal_${timestamp}.zip http://${DEVICE_IP}:${TIBU_PORT}${TIBU_SDINT}" >> "${scriptname}"
  echo "wget -O sdexternal_${timestamp}.zip http://${DEVICE_IP}:${TIBU_PORT}${TIBU_SDEXT}" >> "${scriptname}"
  echo "wget -O tibu_backups_${timestamp}.zip http://${DEVICE_IP}:${TIBU_PORT}${TIBU_BACKUPS}" >> "${scriptname}"
  chmod u+x "${scriptname}"
}


#
# Collect app details via dumpsys
#
getAppDetails() {
  local P_BLOCK="none" # none|pkglist|pkg|disabled|enabled|perms
  local P_PKGNAME=""   # name of the currently processed package
  local tmpstring=""
  local P_SKIP=(userId sharedUser pkg resourcePath nativeLibraryPath versionCode targetSdk timeStamp signatures permissionsFixed pkgFlags applicationInfo)
  declare -A PK_CODEPATH
  declare -A PK_VERSION
  declare -A PK_DATADIR
  declare -A PK_SCREENSIZE
  declare -A PK_FIRSTINSTALL
  declare -A PK_LASTUPDATE
  declare -A PK_INSTALLERS    # per source
  PK_INSTALLERS[none]="unknown source"
  declare -A PK_INSTALLER     # per app
  declare -A PK_DISABLED      # list of components separated by spaces
  declare -A PK_FLAGS         # flags=[ SYSTEM HAS_CODE ALLOW_TASK_REPARENTING ALLOW_CLEAR_USER_DATA ALLOW_BACKUP LARGE_HEAP ]
  declare -A APP_INSTALL_SRC
  APP_INSTALL_SRC[org.fdroid.fdroid]="F-Droid"
  APP_INSTALL_SRC[cm.aptoide.pt]="Aptoide"
  APP_INSTALL_SRC[com.android.vending]="Google Play"
  APP_INSTALL_SRC[com.google.android.feedback]="Google Play (Feedback)"
  local PKGDUMP="dumpsys.$$"
  local SH_DISABLED="${OUTDIR}/deadReceivers.sh"

  doProgress "Generating app detail info"
  doProgress "- collecting data via dumpsys into '${PKGDUMP}'" 2
  adb shell "dumpsys package" |egrep -A99999 "^Packages:" |egrep -B99999 "^Shared users:" > "${PKGDUMP}"

  # Parsing dump
  doProgress "- parsing package dump from '${PKGDUMP}'" 2
  while IFS='' read zeile; do # no idea why, but some dump lines are terminated using CRLF
    case ${P_BLOCK} in
      none)
        [[ "$zeile" != "Packages:" ]] && continue;
        P_BLOCK="pkglist"
        doProgress "  - Found package list marker" 3
        continue;
        ;;

      pkglist)
        if [[ "${zeile:0:11}" = "  Package [" ]]; then  # "  Package [com.google.android.location] (40e85638):"
          tmpstring="${zeile##*[}"                      # strip leading
          P_PKGNAME="${tmpstring%%]*}"                  # strip trailing
          P_BLOCK="pkg"
          doProgress "  - Package: $P_PKGNAME" 3
          continue
        fi
        ;;

      pkg)
        tmpstring="${zeile%%=*}"
        tmpstring="${tmpstring##*[[:space:]]}"
        in_array $tmpstring "${P_SKIP[@]}" && continue
        [[ "$zeile" = "    grantedPermissions:" ]] && continue
        [[ "${zeile:0:6}" = "      " ]] && continue
        [[ -z "${zeile%%* }" ]] && break # end of package list is an empty line, sometimes with spaces
        case "$tmpstring" in
          "codePath")
            PK_CODEPATH[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +codePath: ${PK_CODEPATH[$P_PKGNAME]}" 4
            continue
            ;;
          "versionName")
            PK_VERSION[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +version: ${PK_VERSION[$P_PKGNAME]}" 4
            continue
            ;;
          "dataDir")
            PK_DATADIR[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +data: ${PK_DATADIR[$P_PKGNAME]}" 4
            continue
            ;;
          "supportsScreens")
            PK_SCREENSIZE[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +screens: ${PK_SCREENSIZE[$P_PKGNAME]}" 4
            continue
            ;;
          "firstInstallTime")
            PK_FIRSTINSTALL[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +firstinst: ${PK_FIRSTINSTALL[$P_PKGNAME]}" 4
            continue
            ;;
          "lastUpdateTime")
            PK_LASTUPDATE[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +lastup: ${PK_LASTUPDATE[$P_PKGNAME]}" 4
            continue
            ;;
          "installerPackageName")
            in_array "${zeile##*=}" "${PK_INSTALLERS[@]}" || { # setting up "used sources" to group by
              if [ -z "${APP_INSTALL_SRC[${zeile##*=}]}" ]; then
                PK_INSTALLERS[${zeile##*=}]="${zeile##*=}"
              else
                PK_INSTALLERS[${zeile##*=}]="${APP_INSTALL_SRC[${zeile##*=}]}"
              fi
            }
            PK_INSTALLER[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +installer: ${PK_INSTALLER[$P_PKGNAME]}" 4
            continue
            ;;
          "flags")
            PK_FLAGS[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +flags: ${PK_FLAGS[$P_PKGNAME]}" 4
            continue
            ;;
          *)
            if [[ "${zeile:0:11}" = "  Package [" ]]; then  # "  Package [com.google.android.location] (40e85638):"
              tmpstring="${zeile##*[}"                      # strip leading
              P_PKGNAME="${tmpstring%%]*}"                  # strip trailing
              doProgress "  - Package: $P_PKGNAME" 3
              continue
            fi
            if [[ "${zeile}" = "    disabledComponents:" ]]; then
              P_BLOCK="disabled"
              continue
            fi
            if [[ "${zeile}" = "    enabledComponents:" ]]; then
              P_BLOCK="enabled"
              continue
            fi
echo "Oops in pkg:"
echo -e "Unexpected: '$zeile'"
            ;;
        esac
        ;;

      "disabled") # disabled components of current pkg
        if [[ "${zeile:0:6}" = "      " ]]; then
          if [[ -z "${PK_DISABLED[$P_PKGNAME]}" ]]; then
            PK_DISABLED[$P_PKGNAME]="${zeile:6}"
          else
            PK_DISABLED[$P_PKGNAME]="${PK_DISABLED[$P_PKGNAME]} ${zeile:6}"
          fi
          continue
        fi
        if [[ "${zeile}" = "    grantedPermissions:" ]]; then
          P_BLOCK="perms"
          continue
        fi
        if [[ "${zeile}" = "    enabledComponents:" ]]; then
          P_BLOCK="enabled"
          continue
        fi
        if [[ "${zeile:0:11}" = "  Package [" ]]; then  # "  Package [com.google.android.location] (40e85638):"
          tmpstring="${zeile##*[}"                      # strip leading
          P_PKGNAME="${tmpstring%%]*}"                  # strip trailing
          P_BLOCK="pkg"
          doProgress "  - Package: $P_PKGNAME" 3
          continue
        fi
echo "Oops in disabled:"
echo -e "$zeile"
exit
        ;;

      "enabled") # enabled components of current pkg
        if [[ "${zeile:0:6}" = "      " ]]; then
          continue # we don't include enabled components
        fi
        if [[ "${zeile}" = "    grantedPermissions:" ]]; then
          P_BLOCK="perms"
          continue
        fi
        if [[ "${zeile:0:11}" = "  Package [" ]]; then  # "  Package [com.google.android.location] (40e85638):"
          tmpstring="${zeile##*[}"                      # strip leading
          P_PKGNAME="${tmpstring%%]*}"                  # strip trailing
          P_BLOCK="pkg"
          doProgress "  - Package: $P_PKGNAME" 3
          continue
        fi
echo "Oops in enabled:"
echo -e "$zeile"
        ;;

      "perms")
        if [[ "${zeile:0:6}" = "      " ]]; then
          continue # we don't include permissions (yet)
        fi
        if [[ "${zeile:0:11}" = "  Package [" ]]; then  # "  Package [com.google.android.location] (40e85638):"
          tmpstring="${zeile##*[}"                      # strip leading
          P_PKGNAME="${tmpstring%%]*}"                  # strip trailing
          P_BLOCK="pkg"
          doProgress "  - Package: $P_PKGNAME" 3
          continue
        fi
echo "Oops in perms:"
echo -e "$zeile"
        ;;
      *)
        ;;
    esac

  done < "${PKGDUMP}"

  # Create userApps.md
  doProgress "- generating userApps.md" 2
  local mdfile="${DOCDIR}/userApps.md"
  declare -A APP_INSTALL_SRC
  APP_INSTALL_SRC[org.fdroid.fdroid]="F-Droid"
  APP_INSTALL_SRC[cm.aptoide.pt]="Aptoide"
  APP_INSTALL_SRC[com.android.vending]="Google Play"
  APP_INSTALL_SRC[com.google.android.feedback]="Google Play (Feedback)"

  echo "# Installed User-Apps" > "${mdfile}"
  echo -e "#!/bin/bash\n# Disable Components" > "${SH_DISABLED}"
  declare -A PK_INFO
  for src in ${!PK_INSTALLERS[@]}; do
    PK_INFO[$src]=""
  done
  local CUR_INSTALLER
  for app in ${userApps[@]}; do
    tmpstring="+ $app\n"
    [[ -n "${PK_FIRSTINSTALL[$app]}" ]] && tmpstring+="    + first installed: ${PK_FIRSTINSTALL[$app]}\n"
    [[ -n "${PK_LASTUPDATE[$app]}" ]]   && tmpstring+="    + last updated: ${PK_FIRSTINSTALL[$app]}\n"
    [[ -n "${PK_VERSION[$app]}" ]]      && tmpstring+="    + installed version: ${PK_VERSION[$app]}\n"
    [[ -n "${PK_CODEPATH[$app]}" ]]     && tmpstring+="    + CodePath: ${PK_CODEPATH[$app]}\n"
    [[ -n "${PK_DATADIR[$app]}" ]]      && tmpstring+="    + App data: ${PK_DATADIR[$app]}\n"
    [[ -n "${PK_SCREENSIZE[$app]}" ]]   && tmpstring+="    + supported screen sizes: ${PK_SCREENSIZE[$app]}\n"
    [[ -n "${PK_FLAGS[$app]}" ]]        && tmpstring+="    + flags: ${PK_FLAGS[$app]}\n"
    [[ -n "${PK_DISABLED[$app]}" ]]     && {
      tmpstring+="    + disabled components:\n"
      echo "" >> "${SH_DISABLED}"
      for comp in ${PK_DISABLED[$app]}; do
        tmpstring+="        - $comp\n"
        echo "adb shell \"pm disable ${app}/${comp}\"" >> "${SH_DISABLED}"
      done
    }
    if [[ -z "${PK_INSTALLER[$app]}" ]]; then
      PK_INFO[none]+="$tmpstring\n"
    else
      CUR_INSTALLER="${PK_INSTALLER[$app]}"
      PK_INFO[$CUR_INSTALLER]+="$tmpstring\n"
    fi
  done
  for src in ${!PK_INSTALLERS[@]}; do
    echo -e "## Installed from ${PK_INSTALLERS[$src]} (installer: $src)\n" >> "${mdfile}"
    echo -e "${PK_INFO[$src]}\n" >> "${mdfile}"
  done

  doProgress "- checking for disabled system components" 2
  echo -e "\n\n# Disable System Components" >> "${SH_DISABLED}"
  for app in ${sysApps[@]}; do
    [[ -n "${PK_DISABLED[$app]}" ]]     && {
      echo "" >> "${SH_DISABLED}"
      for comp in ${PK_DISABLED[$app]}; do
        echo "adb shell \"pm disable ${app}/${comp}\"" >> "${SH_DISABLED}"
      done
    }
  done

  doProgress "- removing temporary dumpfile '${PKGDUMP}'" 2
  rm -f "${PKGDUMP}"
}


############################################[ Main ]###
doProgress "\n\033[1;37mAdebar running:\033[0;37m";
pullPackagesXML
initAppLists
getDisabled
getUserAppBackup
getSystemAppBackup
getInstallLoc
getDeviceInfo
getSettings
getTibu
[[ $MK_PKG_DATA -ne 0 ]] && getAppDetails
doProgress "\033[1;37mAdebar done.\033[0;37m\n"

exit 0


######################################[ References ]###
# pm list packages [options] <FILTER>
# options:
#    -f: See their associated file.
#    -d: Filter to only show disabled packages.
#    -e: Filter to only show enabled packages.
#    -s: Filter to only show system packages.
#    -3: Filter to only show third party packages.
#    -i: See the installer for the packages.
#    -u: Also include uninstalled packages.
#    --user <USER_ID>: The user space to query.
#
# disable a component (e.g. BroadcastReceiver): pm disable com.example.com.testapp/.TestActivity
#
# adb pull /data/system/packages.list packages.list
# apps with UID/GID and app path
#
# adb pull /data/system/packages.xml packages.xml
# apps with permissions, intents, etc.:
#
